<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ë„¤íŠ¸ì›Œí¬ ê³¼ì œ2 (DNS, Mail) ë³´ê³ ì„œ</title>

    <!-- ===== ê¸°ì¡´ ìŠ¤íƒ€ì¼ ê·¸ëŒ€ë¡œ ===== -->
    <link
      href="https://fonts.googleapis.com/css2?family=Pretendard:wght@300;400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg: #f9f9fb;
        --surface: #ffffff;
        --primary: #2c5282;
        --primary-dark: #2b6cb0;
        --text: #1a202c;
        --text-light: #4a5568;
        --radius-lg: 1rem;
        --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.05);
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: "Pretendard", sans-serif;
        background: var(--bg);
        color: var(--text);
        line-height: 1.72;
      }
      h1,
      h2,
      h3 {
        color: var(--primary);
        margin-top: 2.2rem;
      }
      h1 {
        font-size: 2.1rem;
        margin-top: 0;
      }
      h2 {
        font-size: 1.55rem;
      }
      h3 {
        font-size: 1.25rem;
      }
      pre {
        background: #eee;
        padding: 1rem;
        overflow-x: auto;
        border-radius: 0.6rem;
        font-size: 0.9rem;
      }
      code {
        font-family: monospace;
      }
      a {
        color: var(--primary-dark);
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
      details > summary {
        cursor: pointer;
        font-weight: 600;
        margin: 0.8rem 0;
      }
      details {
        margin-bottom: 1.45rem;
      }
      .container {
        max-width: 980px;
        margin: 0 auto;
        padding: 3rem 1rem 4rem;
      }
      .badge {
        display: inline-block;
        background: var(--primary);
        color: #fff;
        padding: 0.15rem 0.55rem;
        border-radius: 0.4rem;
        font-size: 0.75rem;
      }
      .tbl {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9rem;
      }
      .tbl th,
      .tbl td {
        border: 1px solid #ddd;
        padding: 0.45rem 0.55rem;
        text-align: left;
      }
      .tbl th {
        background: #f0f3f8;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ header -->
      <header>
        <h1>
          ë„¤íŠ¸ì›Œí¬ ê³¼ì œ2 (DNS, Mail) ë³´ê³ ì„œ <span class="badge">v0.1</span>
        </h1>
      </header>

      <!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ëª©ì°¨ -->
      <h2 id="toc">ëª©ì°¨</h2>
      <ol>
        <li><a href="#plan">í”„ë¡œì íŠ¸ ê¸°íš í•µì‹¬ ìš”ì•½</a></li>
        <li><a href="#arch">ì•„í‚¤í…ì²˜ &amp; ëª¨ë“ˆ íë¦„</a></li>
        <li><a href="#code">ì „ì²´ ì†ŒìŠ¤ì½”ë“œ + ì£¼ìš” ë¡œì§ ì„¤ëª…</a></li>
      </ol>

      <!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 1 -->
      <h2 id="plan">1. í”„ë¡œì íŠ¸ ê¸°íš í•µì‹¬ ìš”ì•½</h2>

      <h3>1-1. ì°¸ì—¬ì ì •ë³´</h3>
      <table class="tbl">
        <tr>
          <th>í•™ë²ˆ</th>
          <th>í•™ê³¼</th>
          <th>ì´ë¦„</th>
        </tr>
        <tr>
          <td>32207033</td>
          <td>ì†Œí”„íŠ¸ì›¨ì–´í•™ê³¼</td>
          <td>ê°•ì¤€í˜•</td>
        </tr>
        <tr>
          <td>32210080</td>
          <td>ì •ì¹˜ì™¸êµí•™ê³¼</td>
          <td>ê°•ìœ ì§„</td>
        </tr>
        <tr>
          <td>32230256</td>
          <td>ì†Œí”„íŠ¸ì›¨ì–´í•™ê³¼</td>
          <td>ê¶Œë¯¼ì§€</td>
        </tr>
        <tr>
          <td>32240745</td>
          <td>ì†Œí”„íŠ¸ì›¨ì–´í•™ê³¼</td>
          <td>ê¹€ì„±ìˆ˜</td>
        </tr>
      </table>

      <h3>1-2. ì‹œìŠ¤í…œ êµ¬ì„± ìš”ì†Œ</h3>
      <table class="tbl">
        <tr>
          <th>êµ¬ì„± ìš”ì†Œ</th>
          <th>ì—­í• </th>
        </tr>
        <tr>
          <td>DNS ì„œë²„</td>
          <td>ë©”ì¼ ì„œë²„ IPÂ·PORTÂ·ìƒíƒœ ê´€ë¦¬, ì£¼ê¸°ì  ìƒíƒœ ëª¨ë‹ˆí„°ë§</td>
        </tr>
        <tr>
          <td>ë©”ì¼ ì„œë²„</td>
          <td>ë©”ì¼ ì†¡ìˆ˜ì‹ , Inbox/Outbox í ì²˜ë¦¬, ì‚¬ìš©ì ëª…ë ¹ ìˆ˜í–‰</td>
        </tr>
        <tr>
          <td>í´ë¼ì´ì–¸íŠ¸</td>
          <td>GUI ì œê³µ, ë¡œê·¸ì¸Â·ë©”ì¼ ì—´ëŒÂ·ì‚­ì œÂ·ì‘ì„±Â·ì „ì†¡</td>
        </tr>
      </table>

      <h3>1-3. ê¸°ìˆ  ìŠ¤íƒÂ·ê°œë°œ ë‹¨ê³„</h3>
      <ul>
        <li>
          <strong>ì‚¬ìš© ì–¸ì–´</strong> : Pythonì„ ê¸°ë°˜ìœ¼ë¡œ TCP ì†Œì¼“ í†µì‹ ì„
          êµ¬í˜„í•˜ì˜€ìŠµë‹ˆë‹¤.
        </li>
        <li>
          <strong>ë°ì´í„°ë² ì´ìŠ¤(DB)</strong> : ê°œë°œ ì´ˆê¸°ì—ëŠ” In-Memory(ë©”ëª¨ë¦¬
          ìƒì—ì„œë§Œ ë°ì´í„° ê´€ë¦¬)ë¥¼ ì‚¬ìš©í•˜ê³  , ì¤‘ê°„ ë‹¨ê³„ì—ì„œëŠ” MySQLì„ ì½ê¸°
          ì „ìš©(Read-only)ìœ¼ë¡œ ë„ì…í•˜ëŠ” ê²ƒì„ ëª©í‘œë¡œ í–ˆìŠµë‹ˆë‹¤. ìµœì¢… ë‹¨ê³„ì—ì„œëŠ”
          MySQLì´ ì½ê¸°/ì“°ê¸°(Read/Write)ë¥¼ ëª¨ë‘ ì§€ì›í•˜ë„ë¡ ë°œì „ì‹œí‚¤ëŠ” ê²ƒì„ ëª©í‘œë¡œ
          í•˜ì˜€ìŠµë‹ˆë‹¤.
        </li>
        <li>
          <strong>ê°œë°œ ë‹¨ê³„</strong> : ì „ì²´ ê°œë°œì€ "ì´ˆê¸° â†’ ì¤‘ê°„ â†’ ì™„ì„±"ì˜ 3ë‹¨ê³„
          ë¡œë“œë§µìœ¼ë¡œ ì§„í–‰ë˜ë©°, ê° ë‹¨ê³„ì—ì„œ ë°ì´í„°ì˜ ì˜ì†ì„±(ë°ì´í„°ë¥¼ ì•ˆì „í•˜ê²Œ
          ë³´ê´€í•˜ê³  ìœ ì§€í•˜ëŠ” ì„±ì§ˆ)ê³¼ ì‹œìŠ¤í…œì˜ í™•ì¥ì„±ì„ ì ì§„ì ìœ¼ë¡œ í™•ë³´í•˜ëŠ” ê²ƒì„
          ê³„íší•˜ì˜€ìŠµë‹ˆë‹¤.
        </li>
      </ul>
      <p>
        <strong
          >ì‹¤ì œë¡œëŠ” ì´ˆê¸° ë‹¨ê³„ì¸ In-Memory ë‹¨ê³„ê¹Œì§€ ê°œë°œì„ ì™„ë£Œí•œ
          ìƒíƒœì…ë‹ˆë‹¤.</strong
        >
      </p>

      <!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 2 -->
      <h2 id="arch">2. ì•„í‚¤í…ì²˜ &amp; ëª¨ë“ˆ íë¦„</h2>

      <h2>2-1. ì‹œìŠ¤í…œ êµ¬ì„± ìš”ì†Œ</h2>
      <ul>
        <li>
          <strong>í´ë¼ì´ì–¸íŠ¸</strong>: GUI ê¸°ë°˜ ë©”ì¼ í´ë¼ì´ì–¸íŠ¸ (ì½˜ì†”, Tkinter,
          CustomTkinter UI ì œê³µ)
        </li>
        <li>
          <strong>ë©”ì¼ ì„œë²„</strong>: ì‚¬ìš©ì ì¸ì¦, ë©”ì¼ ì €ì¥/ì¡°íšŒ/ì‚­ì œ/ì „ì†¡,
          ì†¡ìˆ˜ì‹  í ê´€ë¦¬
        </li>
        <li>
          <strong>DNS ì„œë²„</strong>: ë©”ì¼ ì„œë²„ ë“±ë¡ ë° ìƒíƒœ ëª¨ë‹ˆí„°ë§ (PING/PONG
          ì£¼ê¸° ê²€ì‚¬, ìƒíƒœ ê´€ë¦¬)
        </li>
      </ul>

      <h2>2-2. ì£¼ìš” ë™ì‘ íë¦„</h2>
      <ul>
        <li>í´ë¼ì´ì–¸íŠ¸ëŠ” DNS ì„œë²„ë¡œë¶€í„° ë©”ì¼ ì„œë²„ ëª©ë¡ì„ ì¡°íšŒí•˜ê³  ì„ íƒ</li>
        <li>ë©”ì¼ ì„œë²„ì— TCP ì—°ê²° í›„ ë¡œê·¸ì¸</li>
        <li>ë©”ì¼ ì‘ì„±, ì¡°íšŒ, ì‚­ì œ, ì „ì†¡ ê¸°ëŠ¥ ì œê³µ</li>
        <li>
          ë©”ì¼ ì„œë²„ëŠ”:
          <ul>
            <li>ìì²´ Inbox, Outbox íë¥¼ ê´€ë¦¬</li>
            <li>
              ìì‹ ì´ ì•„ë‹Œ ì„œë²„ë¡œ ì „ì†¡ ì‹œ Outbox â†’ DNS ìƒíƒœ í™•ì¸ â†’ ì „ì†¡ â†’ ì‹¤íŒ¨ ì‹œ
              ì¬ì‹œë„
            </li>
            <li>
              ì™¸ë¶€ ì„œë²„ë¡œë¶€í„° ë©”ì¼ ìˆ˜ì‹  ì‹œ Inboxì— ì¶”ê°€ í›„ ì‚¬ìš©ì ë©”ì¼í•¨ì— ì €ì¥
            </li>
          </ul>
        </li>
        <li>
          DNS ì„œë²„ëŠ”:
          <ul>
            <li>ë©”ì¼ ì„œë²„ ë“±ë¡ ì •ë³´ ê´€ë¦¬ (IP, PORT, ìƒíƒœ)</li>
            <li>ì£¼ê¸°ì ìœ¼ë¡œ PING â†’ PONG ê²€ì‚¬ë¡œ ìƒíƒœ ëª¨ë‹ˆí„°ë§</li>
            <li>FAIL ìƒíƒœë‚˜ ì—°ì† ì‹¤íŒ¨ ì‹œ ì„œë²„ ë“±ë¡ í•´ì œ</li>
          </ul>
        </li>
      </ul>

      <h2>2-3. í´ë¼ì´ì–¸íŠ¸-ì„œë²„ í”„ë¡œí† ì½œ (ì˜ˆì‹œ)</h2>
      <ul>
        <li>
          <code>LOGIN::ID::Password</code> â†’ <code>OK</code> ë˜ëŠ”
          <code>LOGIN_FAIL</code>
        </li>
        <li><code>LIST</code> â†’ ë©”ì¼ ëª©ë¡ (JSON)</li>
        <li>
          <code>READ::MailID</code> â†’ <code>READ_OK::ë©”ì¼ë°ì´í„°</code> ë˜ëŠ”
          <code>NOT_FOUND</code>
        </li>
        <li>
          <code>DELETE::MailID</code> â†’ <code>DELETE_OK</code> ë˜ëŠ”
          <code>DELETE_FAIL</code>
        </li>
        <li>
          <code>SEND::Receiver@Server::Subject::Body</code> â†’
          <code>SEND_OK</code> ë˜ëŠ” <code>SEND_QUEUED</code>
        </li>
      </ul>

      <!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 3 -->
      <h2 id="code">3. ì „ì²´ ì†ŒìŠ¤ì½”ë“œ + ì£¼ìš” ë¡œì§ ì„¤ëª…</h2>
      <p>
        ì†ŒìŠ¤íŒŒì¼ 5ì¢…ì˜ ì „ë¬¸ì„ &lt;details&gt; ë¡œ ì ‘ì–´ ë‘ì—ˆìŠµë‹ˆë‹¤.
        <strong>íŒŒì¼ëª… ì•„ë˜ êµµì€ ê¸€ì”¨</strong>ë¡œ ê° ë¡œì§ í•µì‹¬ë§Œ ê°„ëµ ì£¼ì„
        ì²˜ë¦¬í–ˆìŠµë‹ˆë‹¤.
      </p>

      <!-- PLAN.md --------------------------------------------------- -->
      <h3>3-0. PLAN.md â€“ ê¸°íšì„œ ì›ë³¸</h3>
      <details>
        <summary>ğŸ“„ PLAN.md ì „ë¬¸ í¼ì¹˜ê¸°</summary>
        <pre><code>
          # ë©”ì¼ ì†Œí”„íŠ¸ì›¨ì–´ ì‹œìŠ¤í…œ ê¸°ìˆ  ëª…ì„¸ì„œ v0.1

          ---
          
          ## 1. ë¬¸ì„œ ê°œìš”
          
          | í•­ëª©        | ë‚´ìš©                                                        |
          | ----------- | ----------------------------------------------------------- |
          | ë¬¸ì„œ ëª©ì    | ì‚¬ìš©ì ê°„ ì´ë©”ì¼ ì†¡ìˆ˜ì‹  ê°€ëŠ¥í•œ ê²½ëŸ‰ ì´ë©”ì¼ ì‹œìŠ¤í…œ ê¸°ìˆ  ëª…ì„¸ |
          | ì‹œìŠ¤í…œ ëª©í‘œ | ê¸°ë³¸ ë©”ì¼ ê¸°ëŠ¥, TCP ê¸°ë°˜ ì†Œì¼“ í†µì‹ , í™•ì¥ ê°€ëŠ¥í•œ êµ¬ì¡° ì œê³µ   |
          
          ---
          
          ## 2. ì°¸ì—¬ì ì •ë³´
          
          | í•™ë²ˆ     | í•™ê³¼           | ì´ë¦„   |
          | -------- | -------------- | ------ |
          | 32207033 | ì†Œí”„íŠ¸ì›¨ì–´í•™ê³¼ | ê°•ì¤€í˜• |
          | 32210080 | ì •ì¹˜ì™¸êµí•™ê³¼   | ê°•ìœ ì§„ |
          | 32230256 | ì†Œí”„íŠ¸ì›¨ì–´í•™ê³¼ | ê¶Œë¯¼ì§€ |
          | 32240745 | ì†Œí”„íŠ¸ì›¨ì–´í•™ê³¼ | ê¹€ì„±ìˆ˜ |
          
          ---
          
          ## 3. ì‹œìŠ¤í…œ êµ¬ì„± ìš”ì†Œ
          
          | êµ¬ì„±ìš”ì†Œ   | ê¸°ëŠ¥                                   |
          | ---------- | -------------------------------------- |
          | í´ë¼ì´ì–¸íŠ¸ | GUI ì œê³µ, ì‚¬ìš©ì ìš”ì²­ ì²˜ë¦¬             |
          | ë©”ì¼ ì„œë²„  | ë©”ì¼ ì†¡ìˆ˜ì‹ , í ê´€ë¦¬, ì‚¬ìš©ì ìš”ì²­ ì²˜ë¦¬ |
          | DNS ì„œë²„   | ë©”ì¼ ì„œë²„ IP, PORT, ìƒíƒœ ê´€ë¦¬          |
          
          ---
          
          ## 4. ê¸°ëŠ¥ì  ìš”êµ¬ì‚¬í•­
          
          | êµ¬ì„±ìš”ì†Œ   | í•„ìˆ˜ ê¸°ëŠ¥                                          |
          | ---------- | -------------------------------------------------- |
          | í´ë¼ì´ì–¸íŠ¸ | ë¡œê·¸ì¸, ë¡œê·¸ì•„ì›ƒ, ë©”ì¼ ì¡°íšŒ/ì—´ëŒ/ì‚­ì œ/ì‘ì„± ë° ì „ì†¡ |
          | ë©”ì¼ ì„œë²„  | ë©”ì¼ ì²˜ë¦¬, ì†¡ìˆ˜ì‹  í ê´€ë¦¬, ì‚¬ìš©ì ìš”ì²­ ì²˜ë¦¬        |
          | DNS ì„œë²„   | ë©”ì¼ ì„œë²„ ìƒíƒœ ê´€ë¦¬, ì£¼ê¸°ì  ìƒíƒœ ëª¨ë‹ˆí„°ë§          |
          
          ---
          
          ## 5. ê¸°ìˆ  ìŠ¤íƒ
          
          | ë²”ì£¼            | ì„ íƒ ê¸°ìˆ                 |
          | --------------- | ------------------------ |
          | í”„ë¡œê·¸ë˜ë° ì–¸ì–´ | Python                   |
          | ë„¤íŠ¸ì›Œí¬        | TCP ì†Œì¼“ í”„ë¡œê·¸ë˜ë°      |
          | ë°ì´í„°ë² ì´ìŠ¤    | MySQL (ë‹¨ê³„ë³„ ë„ì… ì˜ˆì •) |
          
          ---
          
          ## 6. ê°œë°œ ë‹¨ê³„
          
          | ë‹¨ê³„      | ì£¼ìš” ë‚´ìš©                                    |
          | --------- | -------------------------------------------- |
          | ì´ˆê¸° ë‹¨ê³„ | ì¸ë©”ëª¨ë¦¬ êµ¬ì¡°ë¡œ ë©”ì¼ ì •ë³´ ê´€ë¦¬               |
          | ì¤‘ê°„ ë‹¨ê³„ | MySQL ì½ê¸° ì „ìš© ë„ì… â†’ ë°ì´í„° ì˜ì†ì„± í™•ë³´    |
          | ì™„ì„± ë‹¨ê³„ | MySQL ì½ê¸°/ì“°ê¸° ì ìš© â†’ í™•ì¥ì„± ë° ë³µêµ¬ì„± ê°•í™” |
          
          ---
          
          ## 7. ë©”ì¼ ì„œë²„ ê°„ í†µì‹  ì„¤ê³„
          
          ### 7.1 ì „ì†¡ ì ˆì°¨
          
          | ë‹¨ê³„ | ì„¤ëª…                                               |
          | ---- | -------------------------------------------------- |
          | 1    | ë©”ì¼ ê°ì²´ ìƒì„± ë° Outbox ì €ì¥                      |
          | 2    | DNS ì„œë²„ ì¡°íšŒ                                      |
          | 3    | ìƒëŒ€ ì„œë²„ ìƒíƒœ í™•ì¸                                |
          | 4    | ìƒíƒœë³„ ì²˜ë¦¬ ë°©ì‹ ê²°ì • (ì¦‰ì‹œ ì „ì†¡/ì¬ì‹œë„/ì‹¤íŒ¨ ê¸°ë¡) |
          | 5    | TCPë¡œ ì™¸ë¶€ ì„œë²„ ì „ì†¡                               |
          | 6    | ìˆ˜ì‹  ê²°ê³¼ì— ë”°ë¼ ì¬ì‹œë„ ë˜ëŠ” ì™„ë£Œ ê¸°ë¡             |
          
          ### 7.2 ìƒíƒœ ì²˜ë¦¬ ì •ì±…
          
          | ìƒíƒœ     | ì²˜ë¦¬ ë°©ì‹                    |
          | -------- | ---------------------------- |
          | OK       | ì¦‰ì‹œ ì „ì†¡                    |
          | OVERLOAD | íì˜ í›„ìˆœìœ„ë¡œ ì´ë™ í›„ ì¬ì‹œë„ |
          | FAIL     | ì „ì†¡ ì‹¤íŒ¨, ë¡œê·¸ ê¸°ë¡         |
          
          ### 7.3 í ê´€ë¦¬ ì „ëµ
          
          | í ìœ í˜• | ë°©í–¥      | ì²˜ë¦¬ ë°©ì‹               |
          | ------- | --------- | ----------------------- |
          | Outbox  | ë‚´ë¶€â†’ì™¸ë¶€ | FIFO, ìƒíƒœ í™•ì¸ í›„ ì²˜ë¦¬ |
          | Inbox   | ì™¸ë¶€â†’ë‚´ë¶€ | ê²€ì¦ í›„ ìœ íš¨ ì‹œ DB ì €ì¥ |
          
          ---
          
          ## 8. í´ë¼ì´ì–¸íŠ¸-ì„œë²„ í†µì‹  í”„ë¡œí† ì½œ
          
          ### 8.1 ëª…ë ¹ ë° ì‘ë‹µ ì½”ë“œ
          
          | ëª…ë ¹   | ìš”ì²­ ì¸ì               | ì‘ë‹µ ì½”ë“œ                      |
          | ------ | ----------------------- | ------------------------------ |
          | LOGIN  | ID, Password            | OK, ID_UNKNOWN, PASSWORD_WRONG |
          | LOGOUT | ì—†ìŒ                    | BYE                            |
          | LIST   | ì—†ìŒ                    | ë©”ì¼ ë©”íƒ€ë°ì´í„°(JSON ë°°ì—´)     |
          | READ   | Mail ID                 | READ_OK, MAIL_NOT_FOUND        |
          | DELETE | Mail ID                 | DELETE_OK, DELETE_FAIL         |
          | SEND   | Receiver, Subject, Body | SEND_OK, SEND_FAIL             |
          
          ### 8.2 ìš”ì²­/ì‘ë‹µ ë©”ì‹œì§€ í˜•ì‹
          
          | êµ¬ë¶„        | í˜•ì‹ ì˜ˆì‹œ                              |
          | ----------- | -------------------------------------- |
          | ìš”ì²­ ë©”ì‹œì§€ | `LOGIN::user::pass`                    |
          | ì‘ë‹µ ë©”ì‹œì§€ | `OK` / `READ_OK::ë³¸ë¬¸ë‚´ìš©` / `SEND_OK` |
          
          ### 8.3 ì—ëŸ¬ ì²˜ë¦¬
          
          | ì—ëŸ¬ ìœ í˜•   | ì‘ë‹µ ë©”ì‹œì§€       |
          | ----------- | ----------------- |
          | ì˜ëª»ëœ ëª…ë ¹ | INVALID_COMMAND   |
          | ì¸ì ë¶€ì¡±   | INVALID_ARGUMENTS |
          | ì¸ì¦ ì‹¤íŒ¨   | UNAUTHORIZED      |
          
          ---
          
          ## 9. í–¥í›„ í™•ì¥ ê³„íš
          
          | í•­ëª©             | ë‚´ìš©                       |
          | ---------------- | -------------------------- |
          | íšŒì›ê°€ì… ì§€ì›    | ì¶”í›„ êµ¬í˜„ ì˜ˆì •             |
          | ì•”í˜¸í™” í†µì‹  ì§€ì› | TLS ë“±                     |
          | ì„œë²„ ì´ì¤‘í™”      | HA(High Availability) êµ¬ì„± |
          | ê´€ë¦¬ì ê¸°ëŠ¥      | ë¡œê·¸, ìƒíƒœ ê´€ë¦¬, í†µê³„      |
          
          ---
          
</code></pre>
      </details>

      <!-- dns.py ---------------------------------------------------- -->
      <h3>3-1. dns.py â€“ DNS Registry Server</h3>
      <p>
        <strong>í•µì‹¬</strong> : ë©”ì¼ ì„œë²„ REGISTER/QUERY/LIST ì²˜ë¦¬ &amp; 10ì´ˆ
        ê°„ê²© Ping Loop
      </p>
      <details>
        <summary>ğŸ“„ dns.py ì „ë¬¸ í¼ì¹˜ê¸°</summary>
        <pre><code>
          import socket
          import json
          import logging
          import threading
          import time
          from datetime import datetime, timezone
          from typing import Dict, Any
          
          
          class DNSRegistryServer:
              def __init__(self, host="0.0.0.0", port=4000):
                  self.host = host
                  self.port = port
                  self.registry: Dict[str, Dict[str, Any]] = {}
                  self.lock = threading.Lock()
                  self.stop_event = threading.Event()
                  self.sock = None
          
                  self.PING_INTERVAL = 10
                  self.PING_TIMEOUT = 3
                  self.PING_MAX_STRIKES = 3
          
                  logging.basicConfig(
                      level=logging.INFO,
                      format="[%(asctime)s] [DNS] [%(levelname)s] %(message)s",
                      datefmt="%Y-%m-%d %H:%M:%S",
                  )
                  self.log = logging.getLogger("dns")
          
              def start(self):
                  self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                  self.sock.settimeout(1.0)
                  self.sock.bind((self.host, self.port))
                  self.sock.listen()
                  self.log.info(f"DNS listening on {self.host}:{self.port}")
          
                  threading.Thread(target=self.ping_loop, daemon=True).start()
          
                  while not self.stop_event.is_set():
                      try:
                          conn, addr = self.sock.accept()
                          threading.Thread(target=self.handle_connection, args=(conn, addr), daemon=True).start()
                      except socket.timeout:
                          continue
                      except KeyboardInterrupt:
                          self.log.info("DNS Shutting Down...")
                          self.stop_event.set()
                          self.sock.close()
                          break
          
              def ping_loop(self):
                  while not self.stop_event.is_set():
                      time.sleep(self.PING_INTERVAL)
                      with self.lock:
                          names = list(self.registry.keys())
          
                      for name in names:
                          with self.lock:
                              info = self.registry.get(name)
                              if not info:
                                  continue
                              ip, port = info["ip"], info["port"]
                              prev_status = info["status"]
          
                          ok = self.ping(ip, port)
                          new_status = "OK" if ok else "FAIL"
          
                          with self.lock:
                              info = self.registry.get(name)
                              if not info:
                                  continue
                              info["status"] = new_status
                              info["last_ping"] = datetime.now(timezone.utc).isoformat()
                              info["strikes"] = 0 if new_status == "OK" else info.get("strikes", 0) + 1
          
                              if new_status != prev_status:
                                  self.log.warning(f"Status Changed: <{name}> {prev_status} â†’ {new_status}")
          
                              if self.PING_MAX_STRIKES and info["strikes"] >= self.PING_MAX_STRIKES:
                                  self.log.error(f"Removed: <{name}> after {info['strikes']} failed pings")
                                  self.registry.pop(name)
          
              def ping(self, ip: str, port: int) -> bool:
                  try:
                      with socket.create_connection((ip, port), timeout=self.PING_TIMEOUT) as s:
                          s.sendall(b"PING")
                          s.settimeout(self.PING_TIMEOUT)
                          return s.recv(4) == b"PONG"
                  except Exception:
                      return False
          
              def handle_connection(self, conn: socket.socket, addr):
                  try:
                      while not self.stop_event.is_set():
                          raw = conn.recv(4096)
                          if not raw:
                              return
          
                          try:
                              req = json.loads(raw.decode())
                          except json.JSONDecodeError:
                              conn.sendall(b'"INVALID_JSON"')
                              return
          
                          typ = req.get("type", "").upper()
          
                          if typ == "REGISTER":
                              name = req["server"]
                              with self.lock:
                                  self.registry[name] = {
                                      "ip": req["ip"],
                                      "port": req["port"],
                                      "status": "OK",
                                      "last_seen": datetime.now(timezone.utc).isoformat(),
                                      "last_ping": None,
                                      "strikes": 0,
                                  }
                              conn.sendall(b'"REGISTERED"')
                              self.log.info(f"Registered <{name}> â†’ {req['ip']}:{req['port']}")
          
                          elif typ == "QUERY":
                              with self.lock:
                                  res = self.registry.get(req["server"], {"status": "FAIL"})
                              conn.sendall(json.dumps(res).encode())
          
                          elif typ == "LIST":
                              with self.lock:
                                  payload = {
                                      "servers": {
                                          name: info
                                          for name, info in self.registry.items()
                                          if info.get("status") == "OK"
                                      }
                                  }
                              conn.sendall(json.dumps(payload).encode())
          
                          else:
                              conn.sendall(b'"INVALID_REQUEST"')
          
                  except Exception as e:
                      self.log.exception(f"Handler error: {e}")
                      try:
                          conn.sendall(b'"ERROR"')
                      except Exception:
                          pass
                  finally:
                      conn.close()
          
          
          if __name__ == "__main__":
              DNSRegistryServer().start()
</code></pre>
      </details>

      <!-- server.py ------------------------------------------------- -->
      <h3>3-2. server.py â€“ Mail Server</h3>
      <p>
        <strong>í•µì‹¬</strong> : í´ë¼ì´ì–¸íŠ¸ ëª…ë ¹ ì²˜ë¦¬, Inbox/Outbox í, DNS
        ë“±ë¡Â·ì¡°íšŒ, PING ì‘ë‹µ
      </p>
      <details>
        <summary>ğŸ“„ server.py ì „ë¬¸ í¼ì¹˜ê¸°</summary>
        <pre><code>
          import json, socket, threading, sys, logging, time
          from datetime import datetime, timezone
          from queue import Queue, Empty
          
          class MailServer:
              def __init__(self, name: str, port: int):
                  self.name = name
                  self.port = port
                  self.dns_host, self.dns_port = "127.0.0.1", 4000
                  self.users = {"u1": "p1", "u2": "p2", "u3": "p3", "u4": "p4"}
                  self.mailbox: dict[str, list[dict]] = dict()
                  self.inbox: Queue[dict] = Queue()
                  self.outbox: Queue[tuple[dict, str, int]] = Queue()
                  self.lock_mailbox = threading.Lock()
                  self.stop_event = threading.Event()
                  self.max_retries = 3
                  self.retry_delay = 5
          
                  logging.basicConfig(
                      level=logging.INFO,
                      format=f"[%(asctime)s] [MAIL:{self.name}] [%(levelname)s] %(message)s",
                      datefmt="%Y-%m-%d %H:%M:%S",
                  )
                  self.log = logging.getLogger("mail")
          
              def gen_mail_id(self) -> str:
                  return f"mail_{int(time.time() * 1000)}"
          
              def dns_register(self):
                  payload = {"type": "REGISTER", "server": self.name, "ip": "127.0.0.1", "port": self.port}
                  with socket.create_connection((self.dns_host, self.dns_port)) as s:
                      s.sendall(json.dumps(payload).encode())
                      s.recv(1024)
                  self.log.info("Registered to DNS")
          
              def dns_query(self, server: str):
                  payload = {"type": "QUERY", "server": server}
                  with socket.create_connection((self.dns_host, self.dns_port)) as s:
                      s.sendall(json.dumps(payload).encode())
                      return json.loads(s.recv(1024).decode())
          
              def send_remote(self, mail: dict, target: dict) -> bool:
                  try:
                      with socket.create_connection((target["ip"], target["port"]), timeout=10) as s:
                          s.sendall(json.dumps(mail).encode())
                          r = s.recv(1024).decode()
                      return r == "RECEIVED"
                  except Exception as e:
                      self.log.error(f"Remote send error: {e}")
                      return False
          
              def handler_client(self, conn: socket.socket, addr):
                  self.log.info(f"Client {addr} connected")
                  user = None
                  try:
                      while not self.stop_event.is_set():
                          data = conn.recv(4096)
                          if not data:
                              break
          
                          cmd, *args = data.decode().strip().split("::")
                          cmd = cmd.upper()
          
                          if cmd == "LOGIN":
                              uid, pw = args
                              if self.users.get(uid) == pw:
                                  user = uid
                                  conn.sendall(b"OK")
                              else:
                                  conn.sendall(b"LOGIN_FAIL")
          
                          elif cmd == "LOGOUT":
                              conn.sendall(b"BYE")
                              break
          
                          elif cmd == "LIST":
                              with self.lock_mailbox:
                                  mails = self.mailbox.get(user, [])
                                  summary = [
                                      {k: m[k] for k in ("id", "sender", "subject", "date")}
                                      for m in mails
                                  ]
                              conn.sendall(json.dumps(summary).encode())
          
                          elif cmd == "READ":
                              mid = args[0]
                              with self.lock_mailbox:
                                  mail = next((m for m in self.mailbox.get(user, []) if m["id"] == mid), None)
                              conn.sendall(f"READ_OK::{mail}".encode() if mail else b"NOT_FOUND")
          
                          elif cmd == "DELETE":
                              mid = args[0]
                              with self.lock_mailbox:
                                  before = len(self.mailbox.get(user, []))
                                  self.mailbox[user] = [m for m in self.mailbox.get(user, []) if m["id"] != mid]
                                  conn.sendall(b"DELETE_OK" if len(self.mailbox[user]) < before else b"DELETE_FAIL")
          
                          elif cmd == "SEND":
                              recv_full, subj, body = args
                              try:
                                  r_user, r_srv = recv_full.split("@")
                              except ValueError:
                                  conn.sendall(b"INVALID_RECEIVER")
                                  continue
          
                              mail = {
                                  "type": "MAIL_TRANSFER",
                                  "id": self.gen_mail_id(),
                                  "sender": f"{user}@{self.name}",
                                  "receiver": r_user,
                                  "subject": subj,
                                  "body": body,
                                  "date": datetime.now(timezone.utc).isoformat(),
                              }
          
                              if r_srv == self.name:
                                  with self.lock_mailbox:
                                      self.mailbox.setdefault(r_user, []).append(mail)
                                  conn.sendall(b"SEND_OK")
                              else:
                                  self.outbox.put((mail, r_srv, 0))
                                  conn.sendall(b"SEND_QUEUED")
                          else:
                              conn.sendall(b"INVALID_CMD")
                  except Exception as e:
                      self.log.exception(f"Client handler error: {e}")
                  finally:
                      conn.close()
                      self.log.info(f"Client {addr} disconnected")
          
              def handler_remote(self, conn: socket.socket, addr):
                  try:
                      if conn.recv(4, socket.MSG_PEEK) == b"PING":
                          conn.recv(4)
                          conn.sendall(b"PONG")
                          return
          
                      mail = json.loads(conn.recv(4096).decode())
                      if mail.get("type") == "MAIL_TRANSFER":
                          self.inbox.put(mail)
                          conn.sendall(b"RECEIVED")
                  except Exception as e:
                      self.log.exception(f"Remote handler error: {e}")
                  finally:
                      conn.close()
          
              def process_inbox(self):
                  processed = 0
                  while True:
                      try:
                          mail = self.inbox.get_nowait()
                      except Empty:
                          break
                      with self.lock_mailbox:
                          self.mailbox.setdefault(mail["receiver"], []).append(mail)
                      self.inbox.task_done()
                      processed += 1
                  if processed:
                      self.log.debug(f"INBOX delivered {processed} mail(s)")
          
              def process_outbox(self):
                  requeue: list[tuple[dict, str, int]] = []
                  while True:
                      try:
                          mail, target_srv, retries = self.outbox.get_nowait()
                      except Empty:
                          break
                      except Exception as e:
                          self.log.error(f"OUTBOX unpack error: {e}")
                          continue
          
                      try:
                          target_info = self.dns_query(target_srv)
                          ok = target_info.get("status") == "OK" and self.send_remote(mail, target_info)
                      except Exception as e:
                          self.log.error(f"DNS or send error: {e}")
                          ok = False
          
                      if ok:
                          self.log.info(f"Outbox delivered {mail['id']} to {target_srv}")
                      else:
                          if retries + 1 < self.max_retries:
                              self.log.warning(f"Retrying mail {mail['id']} to {target_srv} (retry {retries + 1})")
                              requeue.append((mail, target_srv, retries + 1))
                          else:
                              self.log.error(f"Giving up on mail {mail['id']} after {self.max_retries} attempts")
                      self.outbox.task_done()
          
                  if requeue:
                      time.sleep(self.retry_delay)
                      for item in requeue:
                          self.outbox.put(item)
          
              def queue_loop(self):
                  while not self.stop_event.is_set():
                      self.process_inbox()
                      self.process_outbox()
                      time.sleep(1)
          
              def serve(self):
                  self.dns_register()
          
                  sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                  sock.settimeout(1.0)
                  sock.bind(("0.0.0.0", self.port))
                  sock.listen()
                  self.log.info(f"Mail Server listening on 0.0.0.0:{self.port}")
          
                  threading.Thread(target=self.queue_loop, daemon=True).start()
          
                  while True:
                      try:
                          conn, addr = sock.accept()
                          peek = conn.recv(4, socket.MSG_PEEK)
                          target = self.handler_remote if peek.startswith(b"PING") or peek[:1] == b"{" else self.handler_client
                          threading.Thread(target=target, args=(conn, addr), daemon=True).start()
                      except socket.timeout:
                          continue
                      except KeyboardInterrupt:
                          self.log.info("Mail Server shutting downâ€¦")
                          self.stop_event.set()
                          sock.close()
                          time.sleep(1)
                          break
          
          def main():
              if len(sys.argv) != 3:
                  print("Usage: python server.py <server_name> <port>")
                  sys.exit(1)
          
              name = sys.argv[1]
              port = int(sys.argv[2])
              server = MailServer(name, port)
              server.serve()
          
          if __name__ == "__main__":
              main()          
</code></pre>
      </details>

      <!-- client_console.py ---------------------------------------- -->
      <h3>3-3. client_console.py â€“ ì½˜ì†” CLI í´ë¼ì´ì–¸íŠ¸</h3>
      <p>
        <strong>í•µì‹¬</strong> : í„°ë¯¸ë„ì—ì„œ
        <code>LIST / READ / SEND / DELETE</code> ë©”ë‰´ ì¸í„°ë™ì…˜
      </p>
      <details>
        <summary>ğŸ“„ client_console.py ì „ë¬¸ í¼ì¹˜ê¸°</summary>
        <pre><code>
          import socket
          import json
          import logging
          import sys
          
          DNS_HOST, DNS_PORT = "127.0.0.1", 4000
          
          logging.basicConfig(
              level=logging.INFO,
              format="[%(asctime)s] [CLIENT] [%(levelname)s] %(message)s",
              datefmt="%Y-%m-%d %H:%M:%S",
          )
          log = logging.getLogger("client")
          
          
          def dns_list() -> dict:
              with socket.create_connection((DNS_HOST, DNS_PORT)) as s:
                  s.sendall(b'{"type": "LIST"}')
                  return json.loads(s.recv(4096).decode())["servers"]
          
          
          def dns_query(name: str) -> dict:
              with socket.create_connection((DNS_HOST, DNS_PORT)) as s:
                  payload = {"type": "QUERY", "server": name}
                  s.sendall(json.dumps(payload).encode())
                  return json.loads(s.recv(1024).decode())
          
          
          class Client:
              def __init__(self, ip: str, port: int):
                  self.sock = socket.create_connection((ip, port))
                  log.info(f"Connected to server at {ip}:{port}")
          
              def cmd(self, line: str) -> str:
                  self.sock.sendall(line.encode())
                  return self.sock.recv(4096).decode()
          
              def run(self):
                  try:
                      uid = input("ID: ")
                      pw = input("PW: ")
                      if self.cmd(f"LOGIN::{uid}::{pw}") != "OK":
                          print("Login failed.")
                          return
          
                      while True:
                          print("\n1 List  2 Read  3 Delete  4 Send  5 Quit")
                          choice = input("> ").strip()
          
                          if choice == "1":
                              response = self.cmd("LIST")
                              try:
                                  mails = json.loads(response)
                                  for m in mails:
                                      print(f"- [{m['id']}] From: {m['sender']} | Subj: {m['subject']} | Date: {m['date']}")
                              except json.JSONDecodeError:
                                  print("Invalid LIST response:", response)
          
                          elif choice == "2":
                              mid = input("Mail ID: ")
                              print(self.cmd(f"READ::{mid}"))
          
                          elif choice == "3":
                              mid = input("Mail ID: ")
                              print(self.cmd(f"DELETE::{mid}"))
          
                          elif choice == "4":
                              to = input("To (user@server): ")
                              subj = input("Subject: ")
                              body = input("Body: ")
                              print(self.cmd(f"SEND::{to}::{subj}::{body}"))
          
                          elif choice == "5":
                              print(self.cmd("LOGOUT"))
                              break
          
                          else:
                              print("Invalid option.")
          
                  except KeyboardInterrupt:
                      print("\nDisconnected.")
                  except Exception as e:
                      log.exception(f"Unexpected error: {e}")
                  finally:
                      self.sock.close()
                      log.info("Connection closed")
          
          
          def main():
              servers = dns_list()
              if not servers:
                  print("No mail server registered.")
                  return
          
              print("\nAvailable Mail Servers:")
              for idx, name in enumerate(servers, 1):
                  info = servers[name]
                  print(f"{idx}. {name} ({info['ip']}:{info['port']})")
          
              try:
                  sel = int(input("Select server> ")) - 1
                  name = list(servers.keys())[sel]
              except (ValueError, IndexError):
                  print("Invalid selection.")
                  return
          
              info = dns_query(name)
              if info.get("status") != "OK":
                  print(f"Server {name} not found.")
                  return
          
              client = Client(info["ip"], info["port"])
              client.run()
          
          
          if __name__ == "__main__":
              main()          
</code></pre>
      </details>

      <!-- client_form.py ------------------------------------------- -->
      <h3>3-4. client_form.py â€“ Tkinter GUI í´ë¼ì´ì–¸íŠ¸</h3>
      <p>
        <strong>í•µì‹¬</strong> : ê¸°ë³¸ Tk ìœ„ì ¯ìœ¼ë¡œ êµ¬í˜„í•œ ì„œë²„ì„ íƒ â†’ ë¡œê·¸ì¸ â†’
        ë©”ì¸(ìˆ˜ì‹ í•¨Â·ì‘ì„±)
      </p>
      <details>
        <summary>ğŸ“„ client_form.py ì „ë¬¸ í¼ì¹˜ê¸°</summary>
        <pre><code>
          import tkinter as tk
          from tkinter import messagebox, scrolledtext
          import socket
          import json
          
          
          DNS_HOST, DNS_PORT = "127.0.0.1", 4000
          
          
          def dns_list():
              with socket.create_connection((DNS_HOST, DNS_PORT)) as s:
                  s.sendall(b'{"type":"LIST"}')
                  return json.loads(s.recv(4096).decode())["servers"]
          
          
          def dns_query(name):
              with socket.create_connection((DNS_HOST, DNS_PORT)) as s:
                  s.sendall(json.dumps({"type": "QUERY", "server": name}).encode())
                  return json.loads(s.recv(1024).decode())
          
          
          class MailClientApp(tk.Tk):
              def __init__(self):
                  super().__init__()
                  self.title("Potato Mail")
                  self.geometry("700x500")
          
                  self.sock = None
                  self.username = None
                  self.mailbox = []
          
                  self.frames = {}
          
                  self.build_frames()
                  self.show_frame("ServerSelect")
          
              def build_frames(self):
                  self.frames["ServerSelect"] = self.build_server_select_frame()
                  self.frames["Login"] = self.build_login_frame()
                  self.frames["Main"] = self.build_main_frame()
          
              def show_frame(self, name):
                  for frame in self.frames.values():
                      frame.pack_forget()
                  self.frames[name].pack(fill="both", expand=True)
          
              def build_server_select_frame(self):
                  frame = tk.Frame(self)
                  tk.Label(frame, text="Select Mail Server", font=("Arial", 16)).pack(pady=10)
          
                  self.server_listbox = tk.Listbox(frame, width=50)
                  self.server_listbox.pack(pady=10)
          
                  tk.Button(frame, text="Refresh", command=self.refresh_server_list).pack(pady=5)
                  tk.Button(frame, text="Connect", command=self.select_server).pack()
          
                  return frame
          
              def refresh_server_list(self):
                  self.servers = dns_list()
                  self.server_listbox.delete(0, tk.END)
                  for i, name in enumerate(self.servers):
                      info = self.servers[name]
                      self.server_listbox.insert(i, f"{name} ({info['ip']}:{info['port']})")
          
              def select_server(self):
                  try:
                      idx = self.server_listbox.curselection()[0]
                      self.server_name = list(self.servers.keys())[idx]
                      info = dns_query(self.server_name)
                      self.sock = socket.create_connection((info["ip"], info["port"]))
                      self.show_frame("Login")
                  except Exception as e:
                      messagebox.showerror("Error", f"Failed to connect: {e}")
          
              def build_login_frame(self):
                  frame = tk.Frame(self)
          
                  tk.Label(frame, text="Login", font=("Arial", 16)).pack(pady=10)
          
                  self.entry_id = tk.Entry(frame, width=30)
                  self.entry_pw = tk.Entry(frame, width=30, show="*")
                  self.label_login_info = tk.Label(frame, text="", fg="red")
          
                  tk.Label(frame, text="User ID").pack()
                  self.entry_id.pack(pady=2)
                  tk.Label(frame, text="Password").pack()
                  self.entry_pw.pack(pady=2)
          
                  tk.Button(frame, text="Login", command=self.login).pack(pady=10)
                  self.label_login_info.pack()
          
                  return frame
          
              def login(self):
                  uid = self.entry_id.get()
                  pw = self.entry_pw.get()
                  try:
                      self.sock.sendall(f"LOGIN::{uid}::{pw}".encode())
                      res = self.sock.recv(1024).decode()
                      if res == "OK":
                          self.username = uid
                          self.label_login_info.config(text="Login Success", fg="green")
                          self.show_frame("Main")
                          self.load_mail_list()
                      else:
                          self.label_login_info.config(text="Login Failed", fg="red")
                  except Exception as e:
                      self.label_login_info.config(text=f"Error: {e}", fg="red")
          
              def build_main_frame(self):
                  frame = tk.Frame(self)
          
                  # Top buttons
                  tk.Frame(frame).pack()
                  btn_frame = tk.Frame(frame)
                  tk.Button(btn_frame, text="Inbox", command=self.load_mail_list).pack(side="left", padx=5)
                  tk.Button(btn_frame, text="Logout", command=self.logout).pack(side="left", padx=5)
                  btn_frame.pack(pady=10)
          
                  # Mail list
                  tk.Label(frame, text="Inbox", font=("Arial", 14)).pack(pady=5)
                  self.mail_listbox = tk.Listbox(frame, width=100, height=10)
                  self.mail_listbox.pack(padx=10, pady=5)
                  self.mail_listbox.bind("<<ListboxSelect>>", self.read_selected_mail)
          
                  # Compose
                  tk.Label(frame, text="Compose Mail", font=("Arial", 14)).pack(pady=5)
          
                  self.entry_to = tk.Entry(frame, width=70)
                  self.entry_subject = tk.Entry(frame, width=70)
                  self.text_body = scrolledtext.ScrolledText(frame, height=5)
          
                  self.entry_to.pack(pady=2)
                  self.entry_subject.pack(pady=2)
                  self.text_body.pack(pady=5)
          
                  tk.Button(frame, text="Send", command=self.send_mail).pack(pady=5)
                  tk.Button(frame, text="Delete Selected Mail", command=self.delete_selected_mail).pack(pady=5)
          
                  # Mail read area
                  self.label_read = tk.Label(frame, text="Selected Mail Content", font=("Arial", 12))
                  self.text_read = scrolledtext.ScrolledText(frame, height=5)
                  self.label_read.pack(pady=5)
                  self.text_read.pack(padx=10, pady=5)
          
                  return frame
          
              def load_mail_list(self):
                  try:
                      self.sock.sendall(b"LIST")
                      data = self.sock.recv(4096).decode()
                      self.mailbox = json.loads(data)
                      self.mail_listbox.delete(0, tk.END)
                      for i, m in enumerate(self.mailbox):
                          self.mail_listbox.insert(i, f"[{m['id']}] {m['date']} - {m['subject']} from {m['sender']}")
                  except Exception as e:
                      messagebox.showerror("Inbox Error", str(e))
          
              def read_selected_mail(self, event):
                  if not self.mail_listbox.curselection():
                      return
                  idx = self.mail_listbox.curselection()[0]
                  mid = self.mailbox[idx]["id"]
                  try:
                      self.sock.sendall(f"READ::{mid}".encode())
                      res = self.sock.recv(4096).decode()
                      if res.startswith("READ_OK::"):
                          mail_json = res.split("::", 1)[1]
                          mail = eval(mail_json)  # ì•ˆì „í•˜ê²Œ í•˜ë ¤ë©´ json.loads() ì“°ë˜, ì„œë²„ ìª½ JSONìœ¼ë¡œ ë°”ê¾¸ê¸°
                          self.text_read.delete(1.0, tk.END)
                          self.text_read.insert(tk.END, f"From: {mail['sender']}\nTo: {mail['receiver']}\nSubject: {mail['subject']}\n\n{mail['body']}")
                      else:
                          self.text_read.delete(1.0, tk.END)
                          self.text_read.insert(tk.END, "Mail not found.")
                  except Exception as e:
                      messagebox.showerror("Read Error", str(e))
          
              def send_mail(self):
                  to = self.entry_to.get()
                  subj = self.entry_subject.get()
                  body = self.text_body.get("1.0", tk.END).strip()
                  try:
                      self.sock.sendall(f"SEND::{to}::{subj}::{body}".encode())
                      res = self.sock.recv(1024).decode()
                      if res in ("SEND_OK", "SEND_QUEUED"):
                          messagebox.showinfo("Send", "Mail sent successfully.")
                          self.entry_to.delete(0, tk.END)
                          self.entry_subject.delete(0, tk.END)
                          self.text_body.delete("1.0", tk.END)
                          self.load_mail_list()
                      else:
                          messagebox.showerror("Send Failed", res)
                  except Exception as e:
                      messagebox.showerror("Send Error", str(e))
          
              def delete_selected_mail(self):
                  if not self.mail_listbox.curselection():
                      return
                  idx = self.mail_listbox.curselection()[0]
                  mid = self.mailbox[idx]["id"]
                  try:
                      self.sock.sendall(f"DELETE::{mid}".encode())
                      res = self.sock.recv(1024).decode()
                      if res == "DELETE_OK":
                          messagebox.showinfo("Delete", "Mail deleted.")
                          self.load_mail_list()
                          self.text_read.delete(1.0, tk.END)
                      else:
                          messagebox.showerror("Delete Failed", res)
                  except Exception as e:
                      messagebox.showerror("Delete Error", str(e))
          
              def logout(self):
                  try:
                      self.sock.sendall(b"LOGOUT")
                      self.sock.close()
                  except:
                      pass
                  self.username = None
                  self.sock = None
                  self.show_frame("ServerSelect")
          
          
          if __name__ == "__main__":
              app = MailClientApp()
              app.refresh_server_list()
              app.mainloop()          
</code></pre>
      </details>

      <!-- client_ui.py --------------------------------------------- -->
      <h3>3-5. client_ui.py â€“ customtkinter ëª¨ë˜ GUI í´ë¼ì´ì–¸íŠ¸</h3>
      <p>
        <strong>í•µì‹¬</strong> : ë‹¤í¬ëª¨ë“œÂ·ì‚¬ì´ë“œë°”Â·ìŠ¤í¬ë¡¤ëŸ¬ë¸” ì¸ë°•ìŠ¤ ë“± UX í–¥ìƒ
        ë²„ì „
      </p>
      <details>
        <summary>ğŸ“„ client_ui.py ì „ë¬¸ í¼ì¹˜ê¸°</summary>
        <pre><code>
          import customtkinter as ctk
          import socket, json
          from tkinter import messagebox
          
          DNS_HOST, DNS_PORT = "127.0.0.1", 4000
          
          class PotatoMailApp(ctk.CTk):
              def __init__(self):
                  super().__init__()
                  self.title("Potato Mail")
                  self.geometry("1200x800")
                  ctk.set_appearance_mode("dark")
                  ctk.set_default_color_theme("blue")
          
                  self.server_info = None
                  self.sock = None
                  self.username = None
                  self.mailbox = []
          
                  self.build_server_select_frame()
          
              def build_server_select_frame(self):
                  self.clear_window()
                  frame = ctk.CTkFrame(self, corner_radius=12)
                  frame.pack(expand=True, fill="both", padx=60, pady=60)
          
                  ctk.CTkLabel(frame, text="Select Mail Server", font=("Arial", 32, "bold")).pack(pady=(10,30))
                  self.server_list_frame = ctk.CTkScrollableFrame(frame, height=350, width=700)
                  self.server_list_frame.pack(pady=10)
                  ctk.CTkButton(frame, text="Refresh", width=200, command=self.refresh_servers).pack(pady=(20,5))
                  ctk.CTkButton(frame, text="Exit", width=200, command=self.destroy).pack()
          
                  self.refresh_servers()
          
              def refresh_servers(self):
                  for w in self.server_list_frame.winfo_children():
                      w.destroy()
                  try:
                      with socket.create_connection((DNS_HOST, DNS_PORT)) as s:
                          s.sendall(b'{"type":"LIST"}')
                          data = json.loads(s.recv(4096).decode())
                      servers = data.get("servers", {})
                      if not servers:
                          ctk.CTkLabel(self.server_list_frame, text="(No servers found)", text_color="gray").pack(pady=20)
                      for name, info in servers.items():
                          btn = ctk.CTkButton(
                              self.server_list_frame,
                              text=f"{name}  ({info['ip']}:{info['port']})",
                              width=650,
                              height=60,
                              command=lambda n=name: self.select_server(n),
                          )
                          btn.pack(pady=8)
                  except Exception as e:
                      messagebox.showerror("DNS Error", str(e))
          
              def select_server(self, name):
                  try:
                      with socket.create_connection((DNS_HOST, DNS_PORT)) as s:
                          s.sendall(json.dumps({"type":"QUERY","server":name}).encode())
                          info = json.loads(s.recv(1024).decode())
                      self.server_info = {"ip":info["ip"], "port":info["port"]}
                      self.build_login_frame()
                  except Exception as e:
                      messagebox.showerror("Error", f"Cannot query server: {e}")
          
              def build_login_frame(self):
                  self.clear_window()
                  frame = ctk.CTkFrame(self, corner_radius=12)
                  frame.pack(expand=True, fill="both", padx=60, pady=60)
          
                  ctk.CTkLabel(frame, text="Login", font=("Arial", 32, "bold")).pack(pady=(10,30))
                  self.login_id = ctk.CTkEntry(frame, placeholder_text="User ID", width=400)
                  self.login_pw = ctk.CTkEntry(frame, placeholder_text="Password", show="*", width=400)
                  self.login_info = ctk.CTkLabel(frame, text="", text_color="red")
          
                  self.login_id.pack(pady=10)
                  self.login_pw.pack(pady=10)
                  ctk.CTkButton(frame, text="Login", width=200, command=self.login).pack(pady=(30,10))
                  self.login_info.pack()
          
              def login(self):
                  uid, pw = self.login_id.get(), self.login_pw.get()
                  try:
                      self.sock = socket.create_connection((self.server_info["ip"], self.server_info["port"]))
                      self.sock.sendall(f"LOGIN::{uid}::{pw}".encode())
                      res = self.sock.recv(1024).decode()
                      if res == "OK":
                          self.username = uid
                          self.build_main_frame()
                      else:
                          messagebox.showerror("Login Failed", "Invalid credentials. Please select server again.")
                          self.build_server_select_frame()
                  except Exception as e:
                      messagebox.showerror("Error", str(e))
                      self.build_server_select_frame()
          
              def build_main_frame(self):
                  self.clear_window()
                  container = ctk.CTkFrame(self)
                  container.pack(expand=True, fill="both")
          
                  menu = ctk.CTkFrame(container, width=240, fg_color="#1f1f1f")
                  menu.pack(side="left", fill="y", padx=10, pady=10)
                  ctk.CTkLabel(menu, text="Potato Mail", font=("Arial", 24, "bold")).pack(pady=(20,40))
                  ctk.CTkButton(menu, text="Inbox", width=200, command=self.show_inbox).pack(pady=12)
                  ctk.CTkButton(menu, text="Compose", width=200, command=self.show_compose).pack(pady=12)
                  ctk.CTkButton(menu, text="Logout", width=200, command=self.logout).pack(pady=(40,10))
          
                  self.body = ctk.CTkFrame(container)
                  self.body.pack(side="right", expand=True, fill="both", padx=10, pady=10)
          
                  self.show_inbox()
          
              def show_inbox(self):
                  self.clear_body()
                  left = ctk.CTkFrame(self.body)
                  left.pack(side="left", fill="y", padx=(0,10))
          
                  ctk.CTkLabel(left, text="Inbox", font=("Arial", 24, "bold")).pack(pady=(0,15))
                  self.inbox_frame = ctk.CTkScrollableFrame(left, width=350, height=550)
                  self.inbox_frame.pack()
          
                  right = ctk.CTkFrame(self.body)
                  right.pack(side="right", expand=True, fill="both")
          
                  self.read_subject = ctk.CTkLabel(right, text="", font=("Arial", 20, "bold"))
                  self.read_subject.pack(anchor="w", pady=(0,8))
                  self.read_meta = ctk.CTkLabel(right, text="", font=("Arial", 12), text_color="gray")
                  self.read_meta.pack(anchor="w", pady=(0,15))
                  self.read_body = ctk.CTkTextbox(right, width=650, height=480, corner_radius=8)
                  self.read_body.pack(expand=True, fill="both")
          
                  self.refresh_inbox()
          
              def refresh_inbox(self):
                  for w in self.inbox_frame.winfo_children():
                      w.destroy()
                  try:
                      self.sock.sendall(b"LIST")
                      self.mailbox = json.loads(self.sock.recv(4096).decode())
                      if not self.mailbox:
                          ctk.CTkLabel(self.inbox_frame, text="(No mail)", text_color="gray").pack(pady=20)
                          return
                      for m in self.mailbox:
                          btn = ctk.CTkButton(
                              self.inbox_frame,
                              text=f"{m['subject']}\n{m['date']}",
                              width=330, height=70,
                              fg_color="#2a2a2a", hover_color="#333333",
                              command=lambda mid=m["id"]: self.load_mail(mid)
                          )
                          btn.pack(pady=6)
                  except Exception as e:
                      messagebox.showerror("Inbox Error", str(e))
          
              def load_mail(self, mid):
                  try:
                      self.sock.sendall(f"READ::{mid}".encode())
                      res = self.sock.recv(4096).decode()
                      if res.startswith("READ_OK::"):
                          m = json.loads(res.split("::",1)[1].replace("'", '"'))
                          self.read_subject.configure(text=m["subject"])
                          self.read_meta.configure(text=f"From: {m['sender']}    Date: {m['date']}")
                          self.read_body.delete("1.0", "end")
                          self.read_body.insert("end", m["body"])
          
                          right = self.body.winfo_children()[1]
                          for w in right.winfo_children():
                              if isinstance(w, ctk.CTkButton) and w.cget("text") == "Delete":
                                  w.destroy()
                                  
                          delete_btn = ctk.CTkButton(right, text="Delete", width=100, command=lambda mail_id=m["id"]: self.delete_mail(mail_id))
                          delete_btn.pack(anchor="e", pady=(10, 0))
                      else:
                          self.read_subject.configure(text="")
                          self.read_meta.configure(text="")
                          self.read_body.delete("1.0", "end")
                          self.read_body.insert("end", "Mail not found.")
                  except Exception as e:
                      messagebox.showerror("Read Error", str(e))
          
              def show_compose(self):
                  self.clear_body()
                  ctk.CTkLabel(self.body, text="Compose Mail", font=("Arial", 24, "bold")).pack(pady=(0,20))
                  self.to_entry = ctk.CTkEntry(self.body, placeholder_text="To (user@server)", width=700)
                  self.subject_entry = ctk.CTkEntry(self.body, placeholder_text="Subject", width=700)
                  self.body_text = ctk.CTkTextbox(self.body, width=700, height=450, corner_radius=8)
          
                  self.to_entry.pack(pady=12)
                  self.subject_entry.pack(pady=12)
                  self.body_text.pack(pady=12)
                  ctk.CTkButton(self.body, text="Send", width=140, command=self.send_mail).pack(pady=(10,0))
          
              def send_mail(self):
                  to = self.to_entry.get().strip()
                  subj = self.subject_entry.get().strip()
                  body = self.body_text.get("1.0", "end").strip()
                  if not to or not subj:
                      messagebox.showwarning("Input Error", "To and Subject are required.")
                      return
                  try:
                      self.sock.sendall(f"SEND::{to}::{subj}::{body}".encode())
                      res = self.sock.recv(1024).decode()
                      if res in ("SEND_OK", "SEND_QUEUED"):
                          messagebox.showinfo("Success", "Mail sent successfully.")
                          self.show_inbox()
                      else:
                          messagebox.showerror("Send Failed", res)
                  except Exception as e:
                      messagebox.showerror("Send Error", str(e))
          
              def delete_mail(self, mid):
                  if messagebox.askyesno("Confirm Delete", "Are you sure you want to delete this mail?"):
                      try:
                          self.sock.sendall(f"DELETE::{mid}".encode())
                          res = self.sock.recv(1024).decode()
                          if res == "DELETE_OK":
                              messagebox.showinfo("Success", "Mail deleted.")
                              self.show_inbox()
                          else:
                              messagebox.showerror("Delete Failed", res)
                      except Exception as e:
                          messagebox.showerror("Delete Error", str(e))
          
              def logout(self):
                  try:
                      self.sock.sendall(b"LOGOUT")
                      self.sock.close()
                  except:
                      pass
                  self.build_server_select_frame()
          
              def clear_window(self):
                  for w in self.winfo_children():
                      w.destroy()
              def clear_body(self):
                  for w in getattr(self, 'body', []).winfo_children():
                      w.destroy()
          
          
          if __name__ == "__main__":
              app = PotatoMailApp()
              app.mainloop()          
</code></pre>
      </details>
    </div>
  </body>
</html>
