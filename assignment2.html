<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>네트워크 과제2 (DNS, Mail) 보고서</title>

    <!-- ===== 기존 스타일 그대로 ===== -->
    <link
      href="https://fonts.googleapis.com/css2?family=Pretendard:wght@300;400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg: #f9f9fb;
        --surface: #ffffff;
        --primary: #2c5282;
        --primary-dark: #2b6cb0;
        --text: #1a202c;
        --text-light: #4a5568;
        --radius-lg: 1rem;
        --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.05);
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: "Pretendard", sans-serif;
        background: var(--bg);
        color: var(--text);
        line-height: 1.72;
      }
      h1,
      h2,
      h3 {
        color: var(--primary);
        margin-top: 2.2rem;
      }
      h1 {
        font-size: 2.1rem;
        margin-top: 0;
      }
      h2 {
        font-size: 1.55rem;
      }
      h3 {
        font-size: 1.25rem;
      }
      pre {
        background: #eee;
        padding: 1rem;
        overflow-x: auto;
        border-radius: 0.6rem;
        font-size: 0.9rem;
      }
      code {
        font-family: monospace;
      }
      a {
        color: var(--primary-dark);
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
      details > summary {
        cursor: pointer;
        font-weight: 600;
        margin: 0.8rem 0;
      }
      details {
        margin-bottom: 1.45rem;
      }
      .container {
        max-width: 980px;
        margin: 0 auto;
        padding: 3rem 1rem 4rem;
      }
      .badge {
        display: inline-block;
        background: var(--primary);
        color: #fff;
        padding: 0.15rem 0.55rem;
        border-radius: 0.4rem;
        font-size: 0.75rem;
      }
      .tbl {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9rem;
      }
      .tbl th,
      .tbl td {
        border: 1px solid #ddd;
        padding: 0.45rem 0.55rem;
        text-align: left;
      }
      .tbl th {
        background: #f0f3f8;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- ───────────────── header -->
      <header>
        <h1>
          네트워크 과제2 (DNS, Mail) 보고서 <span class="badge">v0.1</span>
        </h1>
      </header>

      <!-- ───────────────── 목차 -->
      <h2 id="toc">목차</h2>
      <ol>
        <li><a href="#plan">프로젝트 기획 핵심 요약</a></li>
        <li><a href="#arch">아키텍처 &amp; 모듈 흐름</a></li>
        <li><a href="#code">전체 소스코드 + 주요 로직 설명</a></li>
      </ol>

      <!-- ───────────────── 1 -->
      <h2 id="plan">1. 프로젝트 기획 핵심 요약</h2>

      <h3>1-1. 참여자 정보</h3>
      <table class="tbl">
        <tr>
          <th>학번</th>
          <th>학과</th>
          <th>이름</th>
        </tr>
        <tr>
          <td>32207033</td>
          <td>소프트웨어학과</td>
          <td>강준형</td>
        </tr>
        <tr>
          <td>32210080</td>
          <td>정치외교학과</td>
          <td>강유진</td>
        </tr>
        <tr>
          <td>32230256</td>
          <td>소프트웨어학과</td>
          <td>권민지</td>
        </tr>
        <tr>
          <td>32240745</td>
          <td>소프트웨어학과</td>
          <td>김성수</td>
        </tr>
      </table>

      <h3>1-2. 시스템 구성 요소</h3>
      <table class="tbl">
        <tr>
          <th>구성 요소</th>
          <th>역할</th>
        </tr>
        <tr>
          <td>DNS 서버</td>
          <td>메일 서버 IP·PORT·상태 관리, 주기적 상태 모니터링</td>
        </tr>
        <tr>
          <td>메일 서버</td>
          <td>메일 송수신, Inbox/Outbox 큐 처리, 사용자 명령 수행</td>
        </tr>
        <tr>
          <td>클라이언트</td>
          <td>GUI 제공, 로그인·메일 열람·삭제·작성·전송</td>
        </tr>
      </table>

      <h3>1-3. 기술 스택·개발 단계</h3>
      <ul>
        <li>
          <strong>사용 언어</strong> : Python을 기반으로 TCP 소켓 통신을
          구현하였습니다.
        </li>
        <li>
          <strong>데이터베이스(DB)</strong> : 개발 초기에는 In-Memory(메모리
          상에서만 데이터 관리)를 사용하고 , 중간 단계에서는 MySQL을 읽기
          전용(Read-only)으로 도입하는 것을 목표로 했습니다. 최종 단계에서는
          MySQL이 읽기/쓰기(Read/Write)를 모두 지원하도록 발전시키는 것을 목표로
          하였습니다.
        </li>
        <li>
          <strong>개발 단계</strong> : 전체 개발은 "초기 → 중간 → 완성"의 3단계
          로드맵으로 진행되며, 각 단계에서 데이터의 영속성(데이터를 안전하게
          보관하고 유지하는 성질)과 시스템의 확장성을 점진적으로 확보하는 것을
          계획하였습니다.
        </li>
      </ul>
      <p>
        <strong
          >실제로는 초기 단계인 In-Memory 단계까지 개발을 완료한
          상태입니다.</strong
        >
      </p>

      <!-- ───────────────── 2 -->
      <h2 id="arch">2. 아키텍처 &amp; 모듈 흐름</h2>

      <h2>2-1. 시스템 구성 요소</h2>
      <ul>
        <li>
          <strong>클라이언트</strong>: GUI 기반 메일 클라이언트 (콘솔, Tkinter,
          CustomTkinter UI 제공)
        </li>
        <li>
          <strong>메일 서버</strong>: 사용자 인증, 메일 저장/조회/삭제/전송,
          송수신 큐 관리
        </li>
        <li>
          <strong>DNS 서버</strong>: 메일 서버 등록 및 상태 모니터링 (PING/PONG
          주기 검사, 상태 관리)
        </li>
      </ul>

      <h2>2-2. 주요 동작 흐름</h2>
      <ul>
        <li>클라이언트는 DNS 서버로부터 메일 서버 목록을 조회하고 선택</li>
        <li>메일 서버에 TCP 연결 후 로그인</li>
        <li>메일 작성, 조회, 삭제, 전송 기능 제공</li>
        <li>
          메일 서버는:
          <ul>
            <li>자체 Inbox, Outbox 큐를 관리</li>
            <li>
              자신이 아닌 서버로 전송 시 Outbox → DNS 상태 확인 → 전송 → 실패 시
              재시도
            </li>
            <li>
              외부 서버로부터 메일 수신 시 Inbox에 추가 후 사용자 메일함에 저장
            </li>
          </ul>
        </li>
        <li>
          DNS 서버는:
          <ul>
            <li>메일 서버 등록 정보 관리 (IP, PORT, 상태)</li>
            <li>주기적으로 PING → PONG 검사로 상태 모니터링</li>
            <li>FAIL 상태나 연속 실패 시 서버 등록 해제</li>
          </ul>
        </li>
      </ul>

      <h2>2-3. 클라이언트-서버 프로토콜 (예시)</h2>
      <ul>
        <li>
          <code>LOGIN::ID::Password</code> → <code>OK</code> 또는
          <code>LOGIN_FAIL</code>
        </li>
        <li><code>LIST</code> → 메일 목록 (JSON)</li>
        <li>
          <code>READ::MailID</code> → <code>READ_OK::메일데이터</code> 또는
          <code>NOT_FOUND</code>
        </li>
        <li>
          <code>DELETE::MailID</code> → <code>DELETE_OK</code> 또는
          <code>DELETE_FAIL</code>
        </li>
        <li>
          <code>SEND::Receiver@Server::Subject::Body</code> →
          <code>SEND_OK</code> 또는 <code>SEND_QUEUED</code>
        </li>
      </ul>

      <!-- ───────────────── 3 -->
      <h2 id="code">3. 전체 소스코드 + 주요 로직 설명</h2>
      <p>
        소스파일 5종의 전문을 &lt;details&gt; 로 접어 두었습니다.
        <strong>파일명 아래 굵은 글씨</strong>로 각 로직 핵심만 간략 주석
        처리했습니다.
      </p>

      <!-- PLAN.md --------------------------------------------------- -->
      <h3>3-0. PLAN.md – 기획서 원본</h3>
      <details>
        <summary>📄 PLAN.md 전문 펼치기</summary>
        <pre><code>
          # 메일 소프트웨어 시스템 기술 명세서 v0.1

          ---
          
          ## 1. 문서 개요
          
          | 항목        | 내용                                                        |
          | ----------- | ----------------------------------------------------------- |
          | 문서 목적   | 사용자 간 이메일 송수신 가능한 경량 이메일 시스템 기술 명세 |
          | 시스템 목표 | 기본 메일 기능, TCP 기반 소켓 통신, 확장 가능한 구조 제공   |
          
          ---
          
          ## 2. 참여자 정보
          
          | 학번     | 학과           | 이름   |
          | -------- | -------------- | ------ |
          | 32207033 | 소프트웨어학과 | 강준형 |
          | 32210080 | 정치외교학과   | 강유진 |
          | 32230256 | 소프트웨어학과 | 권민지 |
          | 32240745 | 소프트웨어학과 | 김성수 |
          
          ---
          
          ## 3. 시스템 구성 요소
          
          | 구성요소   | 기능                                   |
          | ---------- | -------------------------------------- |
          | 클라이언트 | GUI 제공, 사용자 요청 처리             |
          | 메일 서버  | 메일 송수신, 큐 관리, 사용자 요청 처리 |
          | DNS 서버   | 메일 서버 IP, PORT, 상태 관리          |
          
          ---
          
          ## 4. 기능적 요구사항
          
          | 구성요소   | 필수 기능                                          |
          | ---------- | -------------------------------------------------- |
          | 클라이언트 | 로그인, 로그아웃, 메일 조회/열람/삭제/작성 및 전송 |
          | 메일 서버  | 메일 처리, 송수신 큐 관리, 사용자 요청 처리        |
          | DNS 서버   | 메일 서버 상태 관리, 주기적 상태 모니터링          |
          
          ---
          
          ## 5. 기술 스택
          
          | 범주            | 선택 기술                |
          | --------------- | ------------------------ |
          | 프로그래밍 언어 | Python                   |
          | 네트워크        | TCP 소켓 프로그래밍      |
          | 데이터베이스    | MySQL (단계별 도입 예정) |
          
          ---
          
          ## 6. 개발 단계
          
          | 단계      | 주요 내용                                    |
          | --------- | -------------------------------------------- |
          | 초기 단계 | 인메모리 구조로 메일 정보 관리               |
          | 중간 단계 | MySQL 읽기 전용 도입 → 데이터 영속성 확보    |
          | 완성 단계 | MySQL 읽기/쓰기 적용 → 확장성 및 복구성 강화 |
          
          ---
          
          ## 7. 메일 서버 간 통신 설계
          
          ### 7.1 전송 절차
          
          | 단계 | 설명                                               |
          | ---- | -------------------------------------------------- |
          | 1    | 메일 객체 생성 및 Outbox 저장                      |
          | 2    | DNS 서버 조회                                      |
          | 3    | 상대 서버 상태 확인                                |
          | 4    | 상태별 처리 방식 결정 (즉시 전송/재시도/실패 기록) |
          | 5    | TCP로 외부 서버 전송                               |
          | 6    | 수신 결과에 따라 재시도 또는 완료 기록             |
          
          ### 7.2 상태 처리 정책
          
          | 상태     | 처리 방식                    |
          | -------- | ---------------------------- |
          | OK       | 즉시 전송                    |
          | OVERLOAD | 큐의 후순위로 이동 후 재시도 |
          | FAIL     | 전송 실패, 로그 기록         |
          
          ### 7.3 큐 관리 전략
          
          | 큐 유형 | 방향      | 처리 방식               |
          | ------- | --------- | ----------------------- |
          | Outbox  | 내부→외부 | FIFO, 상태 확인 후 처리 |
          | Inbox   | 외부→내부 | 검증 후 유효 시 DB 저장 |
          
          ---
          
          ## 8. 클라이언트-서버 통신 프로토콜
          
          ### 8.1 명령 및 응답 코드
          
          | 명령   | 요청 인자               | 응답 코드                      |
          | ------ | ----------------------- | ------------------------------ |
          | LOGIN  | ID, Password            | OK, ID_UNKNOWN, PASSWORD_WRONG |
          | LOGOUT | 없음                    | BYE                            |
          | LIST   | 없음                    | 메일 메타데이터(JSON 배열)     |
          | READ   | Mail ID                 | READ_OK, MAIL_NOT_FOUND        |
          | DELETE | Mail ID                 | DELETE_OK, DELETE_FAIL         |
          | SEND   | Receiver, Subject, Body | SEND_OK, SEND_FAIL             |
          
          ### 8.2 요청/응답 메시지 형식
          
          | 구분        | 형식 예시                              |
          | ----------- | -------------------------------------- |
          | 요청 메시지 | `LOGIN::user::pass`                    |
          | 응답 메시지 | `OK` / `READ_OK::본문내용` / `SEND_OK` |
          
          ### 8.3 에러 처리
          
          | 에러 유형   | 응답 메시지       |
          | ----------- | ----------------- |
          | 잘못된 명령 | INVALID_COMMAND   |
          | 인자 부족   | INVALID_ARGUMENTS |
          | 인증 실패   | UNAUTHORIZED      |
          
          ---
          
          ## 9. 향후 확장 계획
          
          | 항목             | 내용                       |
          | ---------------- | -------------------------- |
          | 회원가입 지원    | 추후 구현 예정             |
          | 암호화 통신 지원 | TLS 등                     |
          | 서버 이중화      | HA(High Availability) 구성 |
          | 관리자 기능      | 로그, 상태 관리, 통계      |
          
          ---
          
</code></pre>
      </details>

      <!-- dns.py ---------------------------------------------------- -->
      <h3>3-1. dns.py – DNS Registry Server</h3>
      <p>
        <strong>핵심</strong> : 메일 서버 REGISTER/QUERY/LIST 처리 &amp; 10초
        간격 Ping Loop
      </p>
      <details>
        <summary>📄 dns.py 전문 펼치기</summary>
        <pre><code>
          import socket
          import json
          import logging
          import threading
          import time
          from datetime import datetime, timezone
          from typing import Dict, Any
          
          
          class DNSRegistryServer:
              def __init__(self, host="0.0.0.0", port=4000):
                  self.host = host
                  self.port = port
                  self.registry: Dict[str, Dict[str, Any]] = {}
                  self.lock = threading.Lock()
                  self.stop_event = threading.Event()
                  self.sock = None
          
                  self.PING_INTERVAL = 10
                  self.PING_TIMEOUT = 3
                  self.PING_MAX_STRIKES = 3
          
                  logging.basicConfig(
                      level=logging.INFO,
                      format="[%(asctime)s] [DNS] [%(levelname)s] %(message)s",
                      datefmt="%Y-%m-%d %H:%M:%S",
                  )
                  self.log = logging.getLogger("dns")
          
              def start(self):
                  self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                  self.sock.settimeout(1.0)
                  self.sock.bind((self.host, self.port))
                  self.sock.listen()
                  self.log.info(f"DNS listening on {self.host}:{self.port}")
          
                  threading.Thread(target=self.ping_loop, daemon=True).start()
          
                  while not self.stop_event.is_set():
                      try:
                          conn, addr = self.sock.accept()
                          threading.Thread(target=self.handle_connection, args=(conn, addr), daemon=True).start()
                      except socket.timeout:
                          continue
                      except KeyboardInterrupt:
                          self.log.info("DNS Shutting Down...")
                          self.stop_event.set()
                          self.sock.close()
                          break
          
              def ping_loop(self):
                  while not self.stop_event.is_set():
                      time.sleep(self.PING_INTERVAL)
                      with self.lock:
                          names = list(self.registry.keys())
          
                      for name in names:
                          with self.lock:
                              info = self.registry.get(name)
                              if not info:
                                  continue
                              ip, port = info["ip"], info["port"]
                              prev_status = info["status"]
          
                          ok = self.ping(ip, port)
                          new_status = "OK" if ok else "FAIL"
          
                          with self.lock:
                              info = self.registry.get(name)
                              if not info:
                                  continue
                              info["status"] = new_status
                              info["last_ping"] = datetime.now(timezone.utc).isoformat()
                              info["strikes"] = 0 if new_status == "OK" else info.get("strikes", 0) + 1
          
                              if new_status != prev_status:
                                  self.log.warning(f"Status Changed: <{name}> {prev_status} → {new_status}")
          
                              if self.PING_MAX_STRIKES and info["strikes"] >= self.PING_MAX_STRIKES:
                                  self.log.error(f"Removed: <{name}> after {info['strikes']} failed pings")
                                  self.registry.pop(name)
          
              def ping(self, ip: str, port: int) -> bool:
                  try:
                      with socket.create_connection((ip, port), timeout=self.PING_TIMEOUT) as s:
                          s.sendall(b"PING")
                          s.settimeout(self.PING_TIMEOUT)
                          return s.recv(4) == b"PONG"
                  except Exception:
                      return False
          
              def handle_connection(self, conn: socket.socket, addr):
                  try:
                      while not self.stop_event.is_set():
                          raw = conn.recv(4096)
                          if not raw:
                              return
          
                          try:
                              req = json.loads(raw.decode())
                          except json.JSONDecodeError:
                              conn.sendall(b'"INVALID_JSON"')
                              return
          
                          typ = req.get("type", "").upper()
          
                          if typ == "REGISTER":
                              name = req["server"]
                              with self.lock:
                                  self.registry[name] = {
                                      "ip": req["ip"],
                                      "port": req["port"],
                                      "status": "OK",
                                      "last_seen": datetime.now(timezone.utc).isoformat(),
                                      "last_ping": None,
                                      "strikes": 0,
                                  }
                              conn.sendall(b'"REGISTERED"')
                              self.log.info(f"Registered <{name}> → {req['ip']}:{req['port']}")
          
                          elif typ == "QUERY":
                              with self.lock:
                                  res = self.registry.get(req["server"], {"status": "FAIL"})
                              conn.sendall(json.dumps(res).encode())
          
                          elif typ == "LIST":
                              with self.lock:
                                  payload = {
                                      "servers": {
                                          name: info
                                          for name, info in self.registry.items()
                                          if info.get("status") == "OK"
                                      }
                                  }
                              conn.sendall(json.dumps(payload).encode())
          
                          else:
                              conn.sendall(b'"INVALID_REQUEST"')
          
                  except Exception as e:
                      self.log.exception(f"Handler error: {e}")
                      try:
                          conn.sendall(b'"ERROR"')
                      except Exception:
                          pass
                  finally:
                      conn.close()
          
          
          if __name__ == "__main__":
              DNSRegistryServer().start()
</code></pre>
      </details>

      <!-- server.py ------------------------------------------------- -->
      <h3>3-2. server.py – Mail Server</h3>
      <p>
        <strong>핵심</strong> : 클라이언트 명령 처리, Inbox/Outbox 큐, DNS
        등록·조회, PING 응답
      </p>
      <details>
        <summary>📄 server.py 전문 펼치기</summary>
        <pre><code>
          import json, socket, threading, sys, logging, time
          from datetime import datetime, timezone
          from queue import Queue, Empty
          
          class MailServer:
              def __init__(self, name: str, port: int):
                  self.name = name
                  self.port = port
                  self.dns_host, self.dns_port = "127.0.0.1", 4000
                  self.users = {"u1": "p1", "u2": "p2", "u3": "p3", "u4": "p4"}
                  self.mailbox: dict[str, list[dict]] = dict()
                  self.inbox: Queue[dict] = Queue()
                  self.outbox: Queue[tuple[dict, str, int]] = Queue()
                  self.lock_mailbox = threading.Lock()
                  self.stop_event = threading.Event()
                  self.max_retries = 3
                  self.retry_delay = 5
          
                  logging.basicConfig(
                      level=logging.INFO,
                      format=f"[%(asctime)s] [MAIL:{self.name}] [%(levelname)s] %(message)s",
                      datefmt="%Y-%m-%d %H:%M:%S",
                  )
                  self.log = logging.getLogger("mail")
          
              def gen_mail_id(self) -> str:
                  return f"mail_{int(time.time() * 1000)}"
          
              def dns_register(self):
                  payload = {"type": "REGISTER", "server": self.name, "ip": "127.0.0.1", "port": self.port}
                  with socket.create_connection((self.dns_host, self.dns_port)) as s:
                      s.sendall(json.dumps(payload).encode())
                      s.recv(1024)
                  self.log.info("Registered to DNS")
          
              def dns_query(self, server: str):
                  payload = {"type": "QUERY", "server": server}
                  with socket.create_connection((self.dns_host, self.dns_port)) as s:
                      s.sendall(json.dumps(payload).encode())
                      return json.loads(s.recv(1024).decode())
          
              def send_remote(self, mail: dict, target: dict) -> bool:
                  try:
                      with socket.create_connection((target["ip"], target["port"]), timeout=10) as s:
                          s.sendall(json.dumps(mail).encode())
                          r = s.recv(1024).decode()
                      return r == "RECEIVED"
                  except Exception as e:
                      self.log.error(f"Remote send error: {e}")
                      return False
          
              def handler_client(self, conn: socket.socket, addr):
                  self.log.info(f"Client {addr} connected")
                  user = None
                  try:
                      while not self.stop_event.is_set():
                          data = conn.recv(4096)
                          if not data:
                              break
          
                          cmd, *args = data.decode().strip().split("::")
                          cmd = cmd.upper()
          
                          if cmd == "LOGIN":
                              uid, pw = args
                              if self.users.get(uid) == pw:
                                  user = uid
                                  conn.sendall(b"OK")
                              else:
                                  conn.sendall(b"LOGIN_FAIL")
          
                          elif cmd == "LOGOUT":
                              conn.sendall(b"BYE")
                              break
          
                          elif cmd == "LIST":
                              with self.lock_mailbox:
                                  mails = self.mailbox.get(user, [])
                                  summary = [
                                      {k: m[k] for k in ("id", "sender", "subject", "date")}
                                      for m in mails
                                  ]
                              conn.sendall(json.dumps(summary).encode())
          
                          elif cmd == "READ":
                              mid = args[0]
                              with self.lock_mailbox:
                                  mail = next((m for m in self.mailbox.get(user, []) if m["id"] == mid), None)
                              conn.sendall(f"READ_OK::{mail}".encode() if mail else b"NOT_FOUND")
          
                          elif cmd == "DELETE":
                              mid = args[0]
                              with self.lock_mailbox:
                                  before = len(self.mailbox.get(user, []))
                                  self.mailbox[user] = [m for m in self.mailbox.get(user, []) if m["id"] != mid]
                                  conn.sendall(b"DELETE_OK" if len(self.mailbox[user]) < before else b"DELETE_FAIL")
          
                          elif cmd == "SEND":
                              recv_full, subj, body = args
                              try:
                                  r_user, r_srv = recv_full.split("@")
                              except ValueError:
                                  conn.sendall(b"INVALID_RECEIVER")
                                  continue
          
                              mail = {
                                  "type": "MAIL_TRANSFER",
                                  "id": self.gen_mail_id(),
                                  "sender": f"{user}@{self.name}",
                                  "receiver": r_user,
                                  "subject": subj,
                                  "body": body,
                                  "date": datetime.now(timezone.utc).isoformat(),
                              }
          
                              if r_srv == self.name:
                                  with self.lock_mailbox:
                                      self.mailbox.setdefault(r_user, []).append(mail)
                                  conn.sendall(b"SEND_OK")
                              else:
                                  self.outbox.put((mail, r_srv, 0))
                                  conn.sendall(b"SEND_QUEUED")
                          else:
                              conn.sendall(b"INVALID_CMD")
                  except Exception as e:
                      self.log.exception(f"Client handler error: {e}")
                  finally:
                      conn.close()
                      self.log.info(f"Client {addr} disconnected")
          
              def handler_remote(self, conn: socket.socket, addr):
                  try:
                      if conn.recv(4, socket.MSG_PEEK) == b"PING":
                          conn.recv(4)
                          conn.sendall(b"PONG")
                          return
          
                      mail = json.loads(conn.recv(4096).decode())
                      if mail.get("type") == "MAIL_TRANSFER":
                          self.inbox.put(mail)
                          conn.sendall(b"RECEIVED")
                  except Exception as e:
                      self.log.exception(f"Remote handler error: {e}")
                  finally:
                      conn.close()
          
              def process_inbox(self):
                  processed = 0
                  while True:
                      try:
                          mail = self.inbox.get_nowait()
                      except Empty:
                          break
                      with self.lock_mailbox:
                          self.mailbox.setdefault(mail["receiver"], []).append(mail)
                      self.inbox.task_done()
                      processed += 1
                  if processed:
                      self.log.debug(f"INBOX delivered {processed} mail(s)")
          
              def process_outbox(self):
                  requeue: list[tuple[dict, str, int]] = []
                  while True:
                      try:
                          mail, target_srv, retries = self.outbox.get_nowait()
                      except Empty:
                          break
                      except Exception as e:
                          self.log.error(f"OUTBOX unpack error: {e}")
                          continue
          
                      try:
                          target_info = self.dns_query(target_srv)
                          ok = target_info.get("status") == "OK" and self.send_remote(mail, target_info)
                      except Exception as e:
                          self.log.error(f"DNS or send error: {e}")
                          ok = False
          
                      if ok:
                          self.log.info(f"Outbox delivered {mail['id']} to {target_srv}")
                      else:
                          if retries + 1 < self.max_retries:
                              self.log.warning(f"Retrying mail {mail['id']} to {target_srv} (retry {retries + 1})")
                              requeue.append((mail, target_srv, retries + 1))
                          else:
                              self.log.error(f"Giving up on mail {mail['id']} after {self.max_retries} attempts")
                      self.outbox.task_done()
          
                  if requeue:
                      time.sleep(self.retry_delay)
                      for item in requeue:
                          self.outbox.put(item)
          
              def queue_loop(self):
                  while not self.stop_event.is_set():
                      self.process_inbox()
                      self.process_outbox()
                      time.sleep(1)
          
              def serve(self):
                  self.dns_register()
          
                  sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                  sock.settimeout(1.0)
                  sock.bind(("0.0.0.0", self.port))
                  sock.listen()
                  self.log.info(f"Mail Server listening on 0.0.0.0:{self.port}")
          
                  threading.Thread(target=self.queue_loop, daemon=True).start()
          
                  while True:
                      try:
                          conn, addr = sock.accept()
                          peek = conn.recv(4, socket.MSG_PEEK)
                          target = self.handler_remote if peek.startswith(b"PING") or peek[:1] == b"{" else self.handler_client
                          threading.Thread(target=target, args=(conn, addr), daemon=True).start()
                      except socket.timeout:
                          continue
                      except KeyboardInterrupt:
                          self.log.info("Mail Server shutting down…")
                          self.stop_event.set()
                          sock.close()
                          time.sleep(1)
                          break
          
          def main():
              if len(sys.argv) != 3:
                  print("Usage: python server.py <server_name> <port>")
                  sys.exit(1)
          
              name = sys.argv[1]
              port = int(sys.argv[2])
              server = MailServer(name, port)
              server.serve()
          
          if __name__ == "__main__":
              main()          
</code></pre>
      </details>

      <!-- client_console.py ---------------------------------------- -->
      <h3>3-3. client_console.py – 콘솔 CLI 클라이언트</h3>
      <p>
        <strong>핵심</strong> : 터미널에서
        <code>LIST / READ / SEND / DELETE</code> 메뉴 인터랙션
      </p>
      <details>
        <summary>📄 client_console.py 전문 펼치기</summary>
        <pre><code>
          import socket
          import json
          import logging
          import sys
          
          DNS_HOST, DNS_PORT = "127.0.0.1", 4000
          
          logging.basicConfig(
              level=logging.INFO,
              format="[%(asctime)s] [CLIENT] [%(levelname)s] %(message)s",
              datefmt="%Y-%m-%d %H:%M:%S",
          )
          log = logging.getLogger("client")
          
          
          def dns_list() -> dict:
              with socket.create_connection((DNS_HOST, DNS_PORT)) as s:
                  s.sendall(b'{"type": "LIST"}')
                  return json.loads(s.recv(4096).decode())["servers"]
          
          
          def dns_query(name: str) -> dict:
              with socket.create_connection((DNS_HOST, DNS_PORT)) as s:
                  payload = {"type": "QUERY", "server": name}
                  s.sendall(json.dumps(payload).encode())
                  return json.loads(s.recv(1024).decode())
          
          
          class Client:
              def __init__(self, ip: str, port: int):
                  self.sock = socket.create_connection((ip, port))
                  log.info(f"Connected to server at {ip}:{port}")
          
              def cmd(self, line: str) -> str:
                  self.sock.sendall(line.encode())
                  return self.sock.recv(4096).decode()
          
              def run(self):
                  try:
                      uid = input("ID: ")
                      pw = input("PW: ")
                      if self.cmd(f"LOGIN::{uid}::{pw}") != "OK":
                          print("Login failed.")
                          return
          
                      while True:
                          print("\n1 List  2 Read  3 Delete  4 Send  5 Quit")
                          choice = input("> ").strip()
          
                          if choice == "1":
                              response = self.cmd("LIST")
                              try:
                                  mails = json.loads(response)
                                  for m in mails:
                                      print(f"- [{m['id']}] From: {m['sender']} | Subj: {m['subject']} | Date: {m['date']}")
                              except json.JSONDecodeError:
                                  print("Invalid LIST response:", response)
          
                          elif choice == "2":
                              mid = input("Mail ID: ")
                              print(self.cmd(f"READ::{mid}"))
          
                          elif choice == "3":
                              mid = input("Mail ID: ")
                              print(self.cmd(f"DELETE::{mid}"))
          
                          elif choice == "4":
                              to = input("To (user@server): ")
                              subj = input("Subject: ")
                              body = input("Body: ")
                              print(self.cmd(f"SEND::{to}::{subj}::{body}"))
          
                          elif choice == "5":
                              print(self.cmd("LOGOUT"))
                              break
          
                          else:
                              print("Invalid option.")
          
                  except KeyboardInterrupt:
                      print("\nDisconnected.")
                  except Exception as e:
                      log.exception(f"Unexpected error: {e}")
                  finally:
                      self.sock.close()
                      log.info("Connection closed")
          
          
          def main():
              servers = dns_list()
              if not servers:
                  print("No mail server registered.")
                  return
          
              print("\nAvailable Mail Servers:")
              for idx, name in enumerate(servers, 1):
                  info = servers[name]
                  print(f"{idx}. {name} ({info['ip']}:{info['port']})")
          
              try:
                  sel = int(input("Select server> ")) - 1
                  name = list(servers.keys())[sel]
              except (ValueError, IndexError):
                  print("Invalid selection.")
                  return
          
              info = dns_query(name)
              if info.get("status") != "OK":
                  print(f"Server {name} not found.")
                  return
          
              client = Client(info["ip"], info["port"])
              client.run()
          
          
          if __name__ == "__main__":
              main()          
</code></pre>
      </details>

      <!-- client_form.py ------------------------------------------- -->
      <h3>3-4. client_form.py – Tkinter GUI 클라이언트</h3>
      <p>
        <strong>핵심</strong> : 기본 Tk 위젯으로 구현한 서버선택 → 로그인 →
        메인(수신함·작성)
      </p>
      <details>
        <summary>📄 client_form.py 전문 펼치기</summary>
        <pre><code>
          import tkinter as tk
          from tkinter import messagebox, scrolledtext
          import socket
          import json
          
          
          DNS_HOST, DNS_PORT = "127.0.0.1", 4000
          
          
          def dns_list():
              with socket.create_connection((DNS_HOST, DNS_PORT)) as s:
                  s.sendall(b'{"type":"LIST"}')
                  return json.loads(s.recv(4096).decode())["servers"]
          
          
          def dns_query(name):
              with socket.create_connection((DNS_HOST, DNS_PORT)) as s:
                  s.sendall(json.dumps({"type": "QUERY", "server": name}).encode())
                  return json.loads(s.recv(1024).decode())
          
          
          class MailClientApp(tk.Tk):
              def __init__(self):
                  super().__init__()
                  self.title("Potato Mail")
                  self.geometry("700x500")
          
                  self.sock = None
                  self.username = None
                  self.mailbox = []
          
                  self.frames = {}
          
                  self.build_frames()
                  self.show_frame("ServerSelect")
          
              def build_frames(self):
                  self.frames["ServerSelect"] = self.build_server_select_frame()
                  self.frames["Login"] = self.build_login_frame()
                  self.frames["Main"] = self.build_main_frame()
          
              def show_frame(self, name):
                  for frame in self.frames.values():
                      frame.pack_forget()
                  self.frames[name].pack(fill="both", expand=True)
          
              def build_server_select_frame(self):
                  frame = tk.Frame(self)
                  tk.Label(frame, text="Select Mail Server", font=("Arial", 16)).pack(pady=10)
          
                  self.server_listbox = tk.Listbox(frame, width=50)
                  self.server_listbox.pack(pady=10)
          
                  tk.Button(frame, text="Refresh", command=self.refresh_server_list).pack(pady=5)
                  tk.Button(frame, text="Connect", command=self.select_server).pack()
          
                  return frame
          
              def refresh_server_list(self):
                  self.servers = dns_list()
                  self.server_listbox.delete(0, tk.END)
                  for i, name in enumerate(self.servers):
                      info = self.servers[name]
                      self.server_listbox.insert(i, f"{name} ({info['ip']}:{info['port']})")
          
              def select_server(self):
                  try:
                      idx = self.server_listbox.curselection()[0]
                      self.server_name = list(self.servers.keys())[idx]
                      info = dns_query(self.server_name)
                      self.sock = socket.create_connection((info["ip"], info["port"]))
                      self.show_frame("Login")
                  except Exception as e:
                      messagebox.showerror("Error", f"Failed to connect: {e}")
          
              def build_login_frame(self):
                  frame = tk.Frame(self)
          
                  tk.Label(frame, text="Login", font=("Arial", 16)).pack(pady=10)
          
                  self.entry_id = tk.Entry(frame, width=30)
                  self.entry_pw = tk.Entry(frame, width=30, show="*")
                  self.label_login_info = tk.Label(frame, text="", fg="red")
          
                  tk.Label(frame, text="User ID").pack()
                  self.entry_id.pack(pady=2)
                  tk.Label(frame, text="Password").pack()
                  self.entry_pw.pack(pady=2)
          
                  tk.Button(frame, text="Login", command=self.login).pack(pady=10)
                  self.label_login_info.pack()
          
                  return frame
          
              def login(self):
                  uid = self.entry_id.get()
                  pw = self.entry_pw.get()
                  try:
                      self.sock.sendall(f"LOGIN::{uid}::{pw}".encode())
                      res = self.sock.recv(1024).decode()
                      if res == "OK":
                          self.username = uid
                          self.label_login_info.config(text="Login Success", fg="green")
                          self.show_frame("Main")
                          self.load_mail_list()
                      else:
                          self.label_login_info.config(text="Login Failed", fg="red")
                  except Exception as e:
                      self.label_login_info.config(text=f"Error: {e}", fg="red")
          
              def build_main_frame(self):
                  frame = tk.Frame(self)
          
                  # Top buttons
                  tk.Frame(frame).pack()
                  btn_frame = tk.Frame(frame)
                  tk.Button(btn_frame, text="Inbox", command=self.load_mail_list).pack(side="left", padx=5)
                  tk.Button(btn_frame, text="Logout", command=self.logout).pack(side="left", padx=5)
                  btn_frame.pack(pady=10)
          
                  # Mail list
                  tk.Label(frame, text="Inbox", font=("Arial", 14)).pack(pady=5)
                  self.mail_listbox = tk.Listbox(frame, width=100, height=10)
                  self.mail_listbox.pack(padx=10, pady=5)
                  self.mail_listbox.bind("<<ListboxSelect>>", self.read_selected_mail)
          
                  # Compose
                  tk.Label(frame, text="Compose Mail", font=("Arial", 14)).pack(pady=5)
          
                  self.entry_to = tk.Entry(frame, width=70)
                  self.entry_subject = tk.Entry(frame, width=70)
                  self.text_body = scrolledtext.ScrolledText(frame, height=5)
          
                  self.entry_to.pack(pady=2)
                  self.entry_subject.pack(pady=2)
                  self.text_body.pack(pady=5)
          
                  tk.Button(frame, text="Send", command=self.send_mail).pack(pady=5)
                  tk.Button(frame, text="Delete Selected Mail", command=self.delete_selected_mail).pack(pady=5)
          
                  # Mail read area
                  self.label_read = tk.Label(frame, text="Selected Mail Content", font=("Arial", 12))
                  self.text_read = scrolledtext.ScrolledText(frame, height=5)
                  self.label_read.pack(pady=5)
                  self.text_read.pack(padx=10, pady=5)
          
                  return frame
          
              def load_mail_list(self):
                  try:
                      self.sock.sendall(b"LIST")
                      data = self.sock.recv(4096).decode()
                      self.mailbox = json.loads(data)
                      self.mail_listbox.delete(0, tk.END)
                      for i, m in enumerate(self.mailbox):
                          self.mail_listbox.insert(i, f"[{m['id']}] {m['date']} - {m['subject']} from {m['sender']}")
                  except Exception as e:
                      messagebox.showerror("Inbox Error", str(e))
          
              def read_selected_mail(self, event):
                  if not self.mail_listbox.curselection():
                      return
                  idx = self.mail_listbox.curselection()[0]
                  mid = self.mailbox[idx]["id"]
                  try:
                      self.sock.sendall(f"READ::{mid}".encode())
                      res = self.sock.recv(4096).decode()
                      if res.startswith("READ_OK::"):
                          mail_json = res.split("::", 1)[1]
                          mail = eval(mail_json)  # 안전하게 하려면 json.loads() 쓰되, 서버 쪽 JSON으로 바꾸기
                          self.text_read.delete(1.0, tk.END)
                          self.text_read.insert(tk.END, f"From: {mail['sender']}\nTo: {mail['receiver']}\nSubject: {mail['subject']}\n\n{mail['body']}")
                      else:
                          self.text_read.delete(1.0, tk.END)
                          self.text_read.insert(tk.END, "Mail not found.")
                  except Exception as e:
                      messagebox.showerror("Read Error", str(e))
          
              def send_mail(self):
                  to = self.entry_to.get()
                  subj = self.entry_subject.get()
                  body = self.text_body.get("1.0", tk.END).strip()
                  try:
                      self.sock.sendall(f"SEND::{to}::{subj}::{body}".encode())
                      res = self.sock.recv(1024).decode()
                      if res in ("SEND_OK", "SEND_QUEUED"):
                          messagebox.showinfo("Send", "Mail sent successfully.")
                          self.entry_to.delete(0, tk.END)
                          self.entry_subject.delete(0, tk.END)
                          self.text_body.delete("1.0", tk.END)
                          self.load_mail_list()
                      else:
                          messagebox.showerror("Send Failed", res)
                  except Exception as e:
                      messagebox.showerror("Send Error", str(e))
          
              def delete_selected_mail(self):
                  if not self.mail_listbox.curselection():
                      return
                  idx = self.mail_listbox.curselection()[0]
                  mid = self.mailbox[idx]["id"]
                  try:
                      self.sock.sendall(f"DELETE::{mid}".encode())
                      res = self.sock.recv(1024).decode()
                      if res == "DELETE_OK":
                          messagebox.showinfo("Delete", "Mail deleted.")
                          self.load_mail_list()
                          self.text_read.delete(1.0, tk.END)
                      else:
                          messagebox.showerror("Delete Failed", res)
                  except Exception as e:
                      messagebox.showerror("Delete Error", str(e))
          
              def logout(self):
                  try:
                      self.sock.sendall(b"LOGOUT")
                      self.sock.close()
                  except:
                      pass
                  self.username = None
                  self.sock = None
                  self.show_frame("ServerSelect")
          
          
          if __name__ == "__main__":
              app = MailClientApp()
              app.refresh_server_list()
              app.mainloop()          
</code></pre>
      </details>

      <!-- client_ui.py --------------------------------------------- -->
      <h3>3-5. client_ui.py – customtkinter 모던 GUI 클라이언트</h3>
      <p>
        <strong>핵심</strong> : 다크모드·사이드바·스크롤러블 인박스 등 UX 향상
        버전
      </p>
      <details>
        <summary>📄 client_ui.py 전문 펼치기</summary>
        <pre><code>
          import customtkinter as ctk
          import socket, json
          from tkinter import messagebox
          
          DNS_HOST, DNS_PORT = "127.0.0.1", 4000
          
          class PotatoMailApp(ctk.CTk):
              def __init__(self):
                  super().__init__()
                  self.title("Potato Mail")
                  self.geometry("1200x800")
                  ctk.set_appearance_mode("dark")
                  ctk.set_default_color_theme("blue")
          
                  self.server_info = None
                  self.sock = None
                  self.username = None
                  self.mailbox = []
          
                  self.build_server_select_frame()
          
              def build_server_select_frame(self):
                  self.clear_window()
                  frame = ctk.CTkFrame(self, corner_radius=12)
                  frame.pack(expand=True, fill="both", padx=60, pady=60)
          
                  ctk.CTkLabel(frame, text="Select Mail Server", font=("Arial", 32, "bold")).pack(pady=(10,30))
                  self.server_list_frame = ctk.CTkScrollableFrame(frame, height=350, width=700)
                  self.server_list_frame.pack(pady=10)
                  ctk.CTkButton(frame, text="Refresh", width=200, command=self.refresh_servers).pack(pady=(20,5))
                  ctk.CTkButton(frame, text="Exit", width=200, command=self.destroy).pack()
          
                  self.refresh_servers()
          
              def refresh_servers(self):
                  for w in self.server_list_frame.winfo_children():
                      w.destroy()
                  try:
                      with socket.create_connection((DNS_HOST, DNS_PORT)) as s:
                          s.sendall(b'{"type":"LIST"}')
                          data = json.loads(s.recv(4096).decode())
                      servers = data.get("servers", {})
                      if not servers:
                          ctk.CTkLabel(self.server_list_frame, text="(No servers found)", text_color="gray").pack(pady=20)
                      for name, info in servers.items():
                          btn = ctk.CTkButton(
                              self.server_list_frame,
                              text=f"{name}  ({info['ip']}:{info['port']})",
                              width=650,
                              height=60,
                              command=lambda n=name: self.select_server(n),
                          )
                          btn.pack(pady=8)
                  except Exception as e:
                      messagebox.showerror("DNS Error", str(e))
          
              def select_server(self, name):
                  try:
                      with socket.create_connection((DNS_HOST, DNS_PORT)) as s:
                          s.sendall(json.dumps({"type":"QUERY","server":name}).encode())
                          info = json.loads(s.recv(1024).decode())
                      self.server_info = {"ip":info["ip"], "port":info["port"]}
                      self.build_login_frame()
                  except Exception as e:
                      messagebox.showerror("Error", f"Cannot query server: {e}")
          
              def build_login_frame(self):
                  self.clear_window()
                  frame = ctk.CTkFrame(self, corner_radius=12)
                  frame.pack(expand=True, fill="both", padx=60, pady=60)
          
                  ctk.CTkLabel(frame, text="Login", font=("Arial", 32, "bold")).pack(pady=(10,30))
                  self.login_id = ctk.CTkEntry(frame, placeholder_text="User ID", width=400)
                  self.login_pw = ctk.CTkEntry(frame, placeholder_text="Password", show="*", width=400)
                  self.login_info = ctk.CTkLabel(frame, text="", text_color="red")
          
                  self.login_id.pack(pady=10)
                  self.login_pw.pack(pady=10)
                  ctk.CTkButton(frame, text="Login", width=200, command=self.login).pack(pady=(30,10))
                  self.login_info.pack()
          
              def login(self):
                  uid, pw = self.login_id.get(), self.login_pw.get()
                  try:
                      self.sock = socket.create_connection((self.server_info["ip"], self.server_info["port"]))
                      self.sock.sendall(f"LOGIN::{uid}::{pw}".encode())
                      res = self.sock.recv(1024).decode()
                      if res == "OK":
                          self.username = uid
                          self.build_main_frame()
                      else:
                          messagebox.showerror("Login Failed", "Invalid credentials. Please select server again.")
                          self.build_server_select_frame()
                  except Exception as e:
                      messagebox.showerror("Error", str(e))
                      self.build_server_select_frame()
          
              def build_main_frame(self):
                  self.clear_window()
                  container = ctk.CTkFrame(self)
                  container.pack(expand=True, fill="both")
          
                  menu = ctk.CTkFrame(container, width=240, fg_color="#1f1f1f")
                  menu.pack(side="left", fill="y", padx=10, pady=10)
                  ctk.CTkLabel(menu, text="Potato Mail", font=("Arial", 24, "bold")).pack(pady=(20,40))
                  ctk.CTkButton(menu, text="Inbox", width=200, command=self.show_inbox).pack(pady=12)
                  ctk.CTkButton(menu, text="Compose", width=200, command=self.show_compose).pack(pady=12)
                  ctk.CTkButton(menu, text="Logout", width=200, command=self.logout).pack(pady=(40,10))
          
                  self.body = ctk.CTkFrame(container)
                  self.body.pack(side="right", expand=True, fill="both", padx=10, pady=10)
          
                  self.show_inbox()
          
              def show_inbox(self):
                  self.clear_body()
                  left = ctk.CTkFrame(self.body)
                  left.pack(side="left", fill="y", padx=(0,10))
          
                  ctk.CTkLabel(left, text="Inbox", font=("Arial", 24, "bold")).pack(pady=(0,15))
                  self.inbox_frame = ctk.CTkScrollableFrame(left, width=350, height=550)
                  self.inbox_frame.pack()
          
                  right = ctk.CTkFrame(self.body)
                  right.pack(side="right", expand=True, fill="both")
          
                  self.read_subject = ctk.CTkLabel(right, text="", font=("Arial", 20, "bold"))
                  self.read_subject.pack(anchor="w", pady=(0,8))
                  self.read_meta = ctk.CTkLabel(right, text="", font=("Arial", 12), text_color="gray")
                  self.read_meta.pack(anchor="w", pady=(0,15))
                  self.read_body = ctk.CTkTextbox(right, width=650, height=480, corner_radius=8)
                  self.read_body.pack(expand=True, fill="both")
          
                  self.refresh_inbox()
          
              def refresh_inbox(self):
                  for w in self.inbox_frame.winfo_children():
                      w.destroy()
                  try:
                      self.sock.sendall(b"LIST")
                      self.mailbox = json.loads(self.sock.recv(4096).decode())
                      if not self.mailbox:
                          ctk.CTkLabel(self.inbox_frame, text="(No mail)", text_color="gray").pack(pady=20)
                          return
                      for m in self.mailbox:
                          btn = ctk.CTkButton(
                              self.inbox_frame,
                              text=f"{m['subject']}\n{m['date']}",
                              width=330, height=70,
                              fg_color="#2a2a2a", hover_color="#333333",
                              command=lambda mid=m["id"]: self.load_mail(mid)
                          )
                          btn.pack(pady=6)
                  except Exception as e:
                      messagebox.showerror("Inbox Error", str(e))
          
              def load_mail(self, mid):
                  try:
                      self.sock.sendall(f"READ::{mid}".encode())
                      res = self.sock.recv(4096).decode()
                      if res.startswith("READ_OK::"):
                          m = json.loads(res.split("::",1)[1].replace("'", '"'))
                          self.read_subject.configure(text=m["subject"])
                          self.read_meta.configure(text=f"From: {m['sender']}    Date: {m['date']}")
                          self.read_body.delete("1.0", "end")
                          self.read_body.insert("end", m["body"])
          
                          right = self.body.winfo_children()[1]
                          for w in right.winfo_children():
                              if isinstance(w, ctk.CTkButton) and w.cget("text") == "Delete":
                                  w.destroy()
                                  
                          delete_btn = ctk.CTkButton(right, text="Delete", width=100, command=lambda mail_id=m["id"]: self.delete_mail(mail_id))
                          delete_btn.pack(anchor="e", pady=(10, 0))
                      else:
                          self.read_subject.configure(text="")
                          self.read_meta.configure(text="")
                          self.read_body.delete("1.0", "end")
                          self.read_body.insert("end", "Mail not found.")
                  except Exception as e:
                      messagebox.showerror("Read Error", str(e))
          
              def show_compose(self):
                  self.clear_body()
                  ctk.CTkLabel(self.body, text="Compose Mail", font=("Arial", 24, "bold")).pack(pady=(0,20))
                  self.to_entry = ctk.CTkEntry(self.body, placeholder_text="To (user@server)", width=700)
                  self.subject_entry = ctk.CTkEntry(self.body, placeholder_text="Subject", width=700)
                  self.body_text = ctk.CTkTextbox(self.body, width=700, height=450, corner_radius=8)
          
                  self.to_entry.pack(pady=12)
                  self.subject_entry.pack(pady=12)
                  self.body_text.pack(pady=12)
                  ctk.CTkButton(self.body, text="Send", width=140, command=self.send_mail).pack(pady=(10,0))
          
              def send_mail(self):
                  to = self.to_entry.get().strip()
                  subj = self.subject_entry.get().strip()
                  body = self.body_text.get("1.0", "end").strip()
                  if not to or not subj:
                      messagebox.showwarning("Input Error", "To and Subject are required.")
                      return
                  try:
                      self.sock.sendall(f"SEND::{to}::{subj}::{body}".encode())
                      res = self.sock.recv(1024).decode()
                      if res in ("SEND_OK", "SEND_QUEUED"):
                          messagebox.showinfo("Success", "Mail sent successfully.")
                          self.show_inbox()
                      else:
                          messagebox.showerror("Send Failed", res)
                  except Exception as e:
                      messagebox.showerror("Send Error", str(e))
          
              def delete_mail(self, mid):
                  if messagebox.askyesno("Confirm Delete", "Are you sure you want to delete this mail?"):
                      try:
                          self.sock.sendall(f"DELETE::{mid}".encode())
                          res = self.sock.recv(1024).decode()
                          if res == "DELETE_OK":
                              messagebox.showinfo("Success", "Mail deleted.")
                              self.show_inbox()
                          else:
                              messagebox.showerror("Delete Failed", res)
                      except Exception as e:
                          messagebox.showerror("Delete Error", str(e))
          
              def logout(self):
                  try:
                      self.sock.sendall(b"LOGOUT")
                      self.sock.close()
                  except:
                      pass
                  self.build_server_select_frame()
          
              def clear_window(self):
                  for w in self.winfo_children():
                      w.destroy()
              def clear_body(self):
                  for w in getattr(self, 'body', []).winfo_children():
                      w.destroy()
          
          
          if __name__ == "__main__":
              app = PotatoMailApp()
              app.mainloop()          
</code></pre>
      </details>
    </div>
  </body>
</html>
